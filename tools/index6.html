<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="../assets/css.css">
  <link rel="stylesheet" href="../assets/reusables.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
  <title>Back Testing</title>
  <style>
    :root {
      --main-width: 350px;
    }

    html, body {
      margin: 0;
      padding: 0;
    }

    #upload-section {
      position: fixed;
      height: 100%;
      z-index: 1;
      background: rgba(0, 0, 0, 0.5);
      width: var(--main-width);
      overflow: hidden;
      transition: all .5s ease;
      overflow-y: auto;
    }

    #upload-section .h-flex {
      flex-direction: column;
    }

    #upload-section:hover {
      //height: 180px;
    }

    #upload-section > .h-flex {
      gap: 10px;
    }

    #upload-section > .h-flex > div {
      transition: all .5s ease;
    }

    #upload-section > .h-flex > div:nth-child(2),
    #upload-section > .h-flex > div:nth-child(3) {
      //width: 0%;
      opacity: 1;
    }

    #upload-section:hover > .h-flex > div {
      //width: 33%;
      //opacity: 1;
    }

    #scichart-root {
      margin-left: var(--main-width);
    }
  </style>
</head>
<body class="h-style">

<div id="upload-section">
  <div class="h-padded">
    <div class="h-flex">
      <div>
        <h3>Upload and Read a CSV File</h3>
        <p>Export MT5 bars by using CTRL+U then go to Bars tab, filter the range and export, then upload it here: </p>
        <p>More info: <a target="_blank" href="https://myforex.com/en/mt5guide/export-historicaldata.html">Export Historical Data</a></p>
      </div>
      <hr class="h-hr">
      <div>
        <input type="file" id="csvFileInput" accept=".csv">
      </div>
      <hr class="h-hr">
      <label for="backtesting-hour">Backtesting Hour</label>
      <input id="backtesting-hour" type="text" value="08:00:00">
      <label for="NavigateTroughtDates">Navigate trought dates</label>
      <select id="NavigateTroughtDates">
        <option value="2024/6/29">2024/6/29</option>
        <option value="2024/7/1">2024/7/1</option>
        <option value="2024/7/2">2024/7/2</option>
        <option value="2024/7/3">2024/7/3</option>
        <option value="2024/7/4">2024/7/4</option>
      </select>
      <hr class="h-hr">
      <!-- Added input type number with default values -->
      <input id="SLPips" type="number" value="0.0001">
      <input id="TPPips" type="number" value="0.0003">
      <div class="row inline">
        <button class="mybutton" data-anotation="RRBuy" title="RR Tool" disabled>
          <i class="fas fa-ruler-combined"></i> Buy
        </button>
        <button class="mybutton" data-anotation="RRSell" title="RR Tool" disabled>
          <i class="fas fa-ruler-combined"></i> Sell
        </button>
      </div>
      <hr class="h-hr">
      <label for="backtesting-hour">Win Rate</label>
      <input type="number">
      <input type="number">
      <hr class="h-hr">
      <div><textarea id="csvContent" rows="10" style="width: 100%;" class="h-field"></textarea></div>
    </div>
  </div>
</div>
<div id="scichart-root" style="height: 100vh;"></div>

<script src="https://cdn.jsdelivr.net/npm/scichart/index.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
<script>

  const decimals = 5;
  let slSize = parseFloat(document.getElementById('SLPips').value);
  let tpSize = parseFloat(document.getElementById('TPPips').value);

  const getValueFromDate = (date) => {
    return new Date(date).getTime() / 1000;
  }

  document.getElementById('csvFileInput').addEventListener('change', function(event) {
    const file = event.target.files[0];
    if (file) {
        const reader = new FileReader();
        reader.onload = function(e) {
          const content = e.target.result;

          document.getElementById('csvContent').value = content;

          initSciChart(content);
          document.getElementById('scichart-root').style.display = 'block';
        };
        reader.readAsText(file);
    } else {
        alert("No file selected");
    }
  });

  // Define the initSciChart function
  function initSciChart(data) {
    const {
      SciChartSurface,
      NumericAxis,
      FastCandlestickRenderableSeries,
      OhlcDataSeries,
      SciChartJsNavyTheme,
      SciChartJSDarkv2Theme,
      NumberRange,
      MouseWheelZoomModifier,
      ZoomPanModifier,
      ZoomExtentsModifier,
      YAxisDragModifier,
      XAxisDragModifier,
      DateTimeNumericAxis,
      DateLabelProvider,
      EDragMode,
      CursorModifier,
      BoxAnnotation,
      ECoordinateMode,
      getCanvasCoordinatesFromEvent,
      VerticalLineAnnotation,
      SolidColorBrush,
      Colors,
      ELabelPlacement,
      EAnnotationLayer,
      DateRange,
    } = SciChart;

    // Tell SciChart where to get webassembly files from.
    SciChartSurface.useWasmFromCDN();

    // Initialize SciChartSurface. Don't forget to await!
    SciChartSurface.create("scichart-root", {
      theme: new SciChartJsNavyTheme(),
    }).then(({ sciChartSurface, wasmContext }) => {

      // Create a custom theme by implementing all the properties from IThemeProvider
      const customTheme = {
        axisBorder: "Transparent",
        axisTitleColor: "#111",
        annotationsGripsBackroundBrush: "white",
        annotationsGripsBorderBrush: "white",
        axis3DBandsFill: "#1F3D6833",
        axisBandsFill: "#1F3D6833",
        axisPlaneBackgroundFill: "Transparent",
        columnFillBrush: "white",
        columnLineColor: "Transparent",
        cursorLineBrush: "#111",
        downBandSeriesFillColor: "#52CC5490",
        downBandSeriesLineColor: "#E26565FF",
        downBodyBrush: "#F00",
        downWickColor: "#F00",
        gridBackgroundBrush: "white",
        gridBorderBrush: "white",
        labelForegroundBrush: "#EEEEEE",
        legendBackgroundBrush: "#1D2C35",
        lineSeriesColor: "white",
        loadingAnimationBackground: "#111",
        loadingAnimationForeground: "#111",
        majorGridLineBrush: "#222",
        minorGridLineBrush: "#333",
        mountainAreaBrush: "white",
        mountainLineColor: "white",
        overviewFillBrush: "white",
        planeBorderColor: "white",
        rolloverLineBrush: "#FD9F2533",
        rubberBandFillBrush: "#99999933",
        rubberBandStrokeBrush: "#99999977",
        sciChartBackground: "#111",
        scrollbarBackgroundBrush: "white",
        scrollbarBorderBrush: "white",
        scrollbarGripsBackgroundBrush: "white",
        scrollbarViewportBackgroundBrush: "white",
        scrollbarViewportBorderBrush: "white",
        shadowEffectColor: "white",
        textAnnotationBackground: "#333",
        textAnnotationForeground: "#EEEEEE",
        tickTextBrush: "#333",
        upBandSeriesFillColor: "white",
        upBandSeriesLineColor: "white",
        upBodyBrush: "#FFF",
        upWickColor: "#FFF"
      }

      // customTheme = new SciChartJsNavyTheme();
      
      sciChartSurface.applyTheme(customTheme);

      window.sciChartSurface = sciChartSurface;

      // Create an XAxis and YAxis with growBy padding
      // sciChartSurface.xAxes.add(new NumericAxis(wasmContext, { axisTitle: "Time", growBy }));
      // sciChartSurface.yAxes.add(new NumericAxis(wasmContext, { axisTitle: "Price", growBy }));
      
      const buildChartData = (data) => {

        const growBy = new NumberRange(0.1, 0.1);
        // Extract OHLC data from the response

        // Parse CSV content
        const rows = data.trim().split('\r\n'); // Split by lines
        const header = rows[0].split('\t'); // Extract headers
        const rdata = rows.slice(1).map(row => row.split('\t')); // Split rows into fields

        const ohlcData = rdata.map(row => {
          /*https://developers.binance.com/docs/binance-spot-api-docs/rest-api#klinecandlestick-data*/
          /*return {
              time: row[0],
              open: parseFloat(row[1]),
              high: parseFloat(row[2]),
              low: parseFloat(row[3]),
              close: parseFloat(row[4])
          }*/
          
          /* MT5 exported CSV format: */
          return {
            time: `${row[0]} ${row[1]}`,
            open: parseFloat(row[2]),
            high: parseFloat(row[3]),
            low: parseFloat(row[4]),
            close: parseFloat(row[5])
          }
        });

        const minDate = new Date(ohlcData[0].time);
        const maxDate = new Date(ohlcData[ohlcData.length - 1].time);

        // Create an OHLC data series
        const ohlcDataSeries = new OhlcDataSeries(wasmContext, {
          xValues: ohlcData.map((item, index) => {
            let startDate = getValueFromDate(item.time);
            let adjustedStartDate = startDate - 3600 * 1; // offset data to match -1h (matching tradingview time)
            let backTestTime = startDate + 3600;
                        
            var time = item.time.split(' ')[1];
            var selectedHour = document.getElementById('backtesting-hour').value;
            if (time == selectedHour) {
              // Display Backtesting dates:
              // console.log(`BackTesting: ${backTestTime}`);
              sciChartSurface.annotations.add(new VerticalLineAnnotation({
                stroke: "#999",
                axisLabelFill: "#999",
                strokeThickness: 1,
                x1: backTestTime,
                showLabel: true,
                labelPlacement: ELabelPlacement.TopLeft,
                labelValue: "Backtest",
              }));
            }

            return adjustedStartDate;
          }),
          openValues: ohlcData.map(item => item.open),
          highValues: ohlcData.map(item => item.high),
          lowValues: ohlcData.map(item => item.low),
          closeValues: ohlcData.map(item => item.close)
        });
        
        sciChartSurface.xAxes.add(new DateTimeNumericAxis(wasmContext, {
          XAxis: new DateLabelProvider({ format: "HH:mm:ss" }),
          //visibleRange: new NumberRange(minDate.getTime() / 1000, maxDate.getTime() / 1000),
          growBy
        }));
        sciChartSurface.yAxes.add(new NumericAxis(wasmContext, {
          labelPrecision: decimals,
          growBy
        }));

        // Create an OHLC series
        sciChartSurface.renderableSeries.add(new FastCandlestickRenderableSeries(wasmContext, {
          dataSeries: ohlcDataSeries,
          strokeThickness: 1,
        }));

        // Add CursorModifier for crosshair
        sciChartSurface.chartModifiers.add(new CursorModifier({
          // Optional properties to configure what parts are shown
          showTooltip: false,
          showAxisLabels: true,
          showXLine: true,
          showYLine: true,
          // How close to a datapoint to show the tooltip? 10 = 10 pixels. 0 means always
          // hitTestRadius: 10,
          // Optional properties to configure the axis labels
          axisLabelFill: "#555",
          axisLabelStroke: "#ccc",
          // Optional properties to configure line and tooltip style
          crosshairStroke: "#555",
          crosshairStrokeThickness: 1,
          tooltipContainerBackground: "#000",
          // tooltipTextStroke: "#ff6600",
        }));

        sciChartSurface
          .chartModifiers
            .add(
              new MouseWheelZoomModifier(),
              new ZoomPanModifier(),
              new ZoomExtentsModifier(),
              new YAxisDragModifier({
                dragMode: EDragMode.Scaling,
              }),
              new XAxisDragModifier({
                dragMode: EDragMode.Scaling,
              }),
            );
      }

      buildChartData(data);
      // Axios code to fetch data
      /*
        axios.get('https://api.binance.com/api/v3/klines?symbol=LTCBTC&interval=1m')
          .then(response => {
            const data = response.data;

            // buildChartData(data);

          })
          .catch(error => {
            console.error('Error fetching data:', error);
          });
      */

      /*
        sciChartSurface.domCanvas2D.addEventListener('click', (event) => {
          //const coords = getCanvasCoordinatesFromEvent(sciChartSurface.domCanvas2D, event);
          //console.log(coords);
        });
      */

      document.getElementById('NavigateTroughtDates').addEventListener('change', function(event) {
        const selectedDate = event.target.value;
        const rangeMinDate = getValueFromDate(selectedDate);
        const rangeMaxDate = getValueFromDate(selectedDate) + 86400; // 1 day

        console.log(`Visible Range: ${rangeMinDate}, ${rangeMaxDate}`);

        sciChartSurface.xAxes.get(0).visibleRange = {min: rangeMinDate, max: rangeMaxDate};

        sciChartSurface.zoomExtents();
      });
      
      // Load Tools:
      document.querySelectorAll('[data-anotation]').forEach(button => {
        button.removeAttribute('disabled');
        button.addEventListener("click", function() {
          let isListeningForToolActions = true;
          var anotationType = this.dataset.anotation;
          const rect = sciChartSurface.domCanvas2D.getBoundingClientRect();
          const RRToolStyles = {
            strokeThickness: 0,
            xCoordinateMode: ECoordinateMode.DataValue,
            yCoordinateMode: ECoordinateMode.DataValue,
            annotationLayer: EAnnotationLayer.AboveChart,
            opacity: '15',
          };
          const RRToolBoxAnnotation = (options, xGraphValue, yGraphValue) => new BoxAnnotation({
            ...RRToolStyles,
            x1: xGraphValue - 50, //firstXValue,
            x2: xGraphValue + 300, //xDataValue,
            y1: yGraphValue,
            ...options,
          })

          switch(anotationType) {
            case 'RRBuy':
              const rrTool = () => {
                let entryYValue = null;

                sciChartSurface.domCanvas2D.addEventListener('click', (event) => {
                  if (!isListeningForToolActions) {
                    return;
                  }

                  const mouseX = event.clientX - rect.left;
                  const mouseY = event.clientY - rect.top - 10; // -10 to offset the canvas position

                  const xCoordCalc = sciChartSurface.xAxes.get(0).getCurrentCoordinateCalculator();
                  const yCoordCalc = sciChartSurface.yAxes.get(0).getCurrentCoordinateCalculator();
                  
                  const xGraphValue = parseFloat(xCoordCalc.getDataValue(mouseX).toFixed(0));
                  const yGraphValue = parseFloat(yCoordCalc.getDataValue(mouseY).toFixed(decimals));

                  sciChartSurface.annotations.add(
                    RRToolBoxAnnotation({
                      fill: `#FF0000${RRToolStyles.opacity}`,
                      y2: yGraphValue - slSize,
                    }, xGraphValue, yGraphValue)
                  );
                  sciChartSurface.annotations.add(
                    RRToolBoxAnnotation({
                      fill: `#00FF00${RRToolStyles.opacity}`,
                      y2: yGraphValue + tpSize,
                    }, xGraphValue, yGraphValue)
                  );

                  isListeningForToolActions = false;
                });
              }
              rrTool();
              break;
            case 'RRSell':
              const rrTool2 = () => {
                let entryYValue = null;

                sciChartSurface.domCanvas2D.addEventListener('click', (event) => {
                  if (!isListeningForToolActions) {
                    return;
                  }

                  const mouseX = event.clientX - rect.left;
                  const mouseY = event.clientY - rect.top - 10; // -10 to offset the canvas position

                  const xCoordCalc = sciChartSurface.xAxes.get(0).getCurrentCoordinateCalculator();
                  const yCoordCalc = sciChartSurface.yAxes.get(0).getCurrentCoordinateCalculator();
                  
                  const xGraphValue = parseFloat(xCoordCalc.getDataValue(mouseX).toFixed(0));
                  const yGraphValue = parseFloat(yCoordCalc.getDataValue(mouseY).toFixed(decimals));

                  sciChartSurface.annotations.add(
                    RRToolBoxAnnotation({
                      fill: `#FF0000${RRToolStyles.opacity}`,
                      y2: yGraphValue + slSize,
                    }, xGraphValue, yGraphValue)
                  );
                  sciChartSurface.annotations.add(
                    RRToolBoxAnnotation({
                      fill: `#00FF00${RRToolStyles.opacity}`,
                      y2: yGraphValue - tpSize,
                    }, xGraphValue, yGraphValue)
                  );

                  isListeningForToolActions = false;
                });
              }
              rrTool2();
              break;
            default:
              alert('No type');
          }
        });
      });

      // Add some interaction modifiers to show zooming and panning
      // sciChartSurface.chartModifiers.add(new MouseWheelZoomModifier(), new ZoomPanModifier(), new ZoomExtentsModifier());
    }).catch(error => {
      console.error('Error initializing SciChart:', error);
    });

  }

  // Add some interaction modifiers to show zooming and panning
  // sciChartSurface.chartModifiers.add(new MouseWheelZoomModifier(), new ZoomPanModifier(), new ZoomExtentsModifier());
  
  // Call initSciChart after the window has finished loading
  // window.onload = initSciChart;
</script>
</body>
</html>
