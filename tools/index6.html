<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" href="../assets/css.css" />
  <link rel="stylesheet" href="../assets/reusables.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css" />
  <link rel="icon" href="https://ui-avatars.com/api/?name=H&rounded=true&background=000000&color=ffffff" type="image/png">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="../assets/reusables.js"></script>
  <script>document.addEventListener('DOMContentLoaded', function() { document.title = `HYTEK - ${document.getElementsByTagName("h1")[0].innerText}` });</script>
  <style>
    :root {
      --main-width: 350px;
      --padding: 15px;
    }

    html,
    body {
      margin: 0;
      padding: 0;
    }

    #upload-section {
      position: fixed;
      height: 100%;
      z-index: 2;
      background: rgba(0, 0, 0, 0.5);
      width: var(--main-width);
      overflow: hidden;
      transition: all 0.5s ease;
      overflow-y: auto;
    }

    #upload-section>.h-flex {
      gap: 10px;
    }

    #upload-section>.h-flex>div {
      transition: all 0.5s ease;
    }

    .chart-section {
      position: relative;
      display: flex;
      flex-direction: column;
      height: 100vh;
      margin-left: var(--main-width);
    }

    #scichart-root {
      flex-grow: 1;
    }

    .result-panel {
      position: relative;
      height: 60px;
      background: black;
      color: white;
      overflow-y: auto;
      z-index: 1;
      transition: all .5s ease;
    }

    .result-panel-toolbar {
      position: fixed;
      display: flex;
      left: var(--main-width);
      right: 0;
      gap: var(--padding);
      padding: 10px;
      background: var(--dark);
      box-shadow: 0 10px 20px -5px var(--dark3);
      box-sizing: border-box;
    }

    .result-panel-content {
      padding: 20px;
      padding-top: 90px;
    }

    .result-panel-toolbar-toggler {
      span:first-child { display: inline; }
      span:last-child { display: none; }
    }

    /* When the result panel is active: */
    .result-panel.active {
      height: 500px;
    }

    .active .result-panel-toolbar-toggler {
      span:first-child { display: none; }
      span:last-child { display: inline; }
    }

    #hidder {
      display: none;
      left: 800px;
      right: 69px;
      top: 0;
      bottom: 24px;
      background: #141515;
      z-index: 1;
      position: absolute;
    }

    .tools,
    .rules {
      position: fixed;
      top: var(--padding);
      right: var(--padding);
      background-color: var(--transparent-dark3);
      padding: calc(var(--padding) / 2);
      border-radius: 5px;
      z-index: 2;
    }

    .rules {
      top: auto;
      bottom: 40px;
    }

    .spacer {
      flex-grow: 1;
    }

    .accordion {
      width: 100%;
      border: 1px solid var(--dark3);
      border-radius: var(--radius);
      overflow: hidden;
    }

    .accordion-item {
      border-bottom: 1px solid var(--dark3);
    }

    .accordion-header {
      background-color: var(--dark);
      cursor: pointer;
    }

    .accordion-button {
      background-color: var(--dark2);
      border: none;
      font-size: 16px;
      text-align: left;
      width: 100%;
      padding: 10px;
      cursor: pointer;
      color: var(--grey1);
      text-transform: uppercase;
      font-weight: bold;
    }

    .accordion-button:focus {
      outline: none;
    }

    .accordion-collapse {
      height: 0;
      overflow: hidden;
      transition: height 0.3s ease;
    }

    .accordion-collapse.show {
      height: auto;
    }

    .accordion-body {
      padding: var(--padding);
      background-color: var(--dark);
      display: flex;
      flex-direction: column;
      gap: var(--padding);
    }

    #chatGPTFloatingIconButtonForModal {
      background: var(--dark);
      color: var(--grey1);
      border: none;
      position: absolute;
      box-shadow: 0 0 60px 5px grey;
      border: 10px solid black;
      bottom: 20px;
      right: 20px;
      width: 50px;
      height: 50px;
      padding: 10px;
      border-radius: 100%;
      cursor: pointer;
      background-image: url('../assets/images/icons/chatGPT.png');
      background-size: 100%;
      background-repeat: no-repeat;
    }

    .loading-element {
      position: absolute;
      top: 0;
      background: rgba(0, 0, 0, 0.7);
      border-radius: 10px;
      padding: 20px 20px 20px 60px;
      z-index: 1;
      opacity: 0;
      transition: opacity 1s ease;
      color: red;
    }

    .loading-element.visible {
      opacity: 1;
    }

    .loading-element .spinner {
      position: absolute;
      top: 0;
      left: 10px;
      border: 1px solid rgba(255, 0, 0, 1);
      box-shadow: 0 0 10px red;
      border-left-color: black;
      border-radius: 50%;
      width: 10px;
      height: 10px;
      animation: scaletrans .6s ease-out infinite alternate;
      transform: scale(1);
      margin: 20px;
    }

    @keyframes scaletrans {
      0% {
      transform: scale(1) rotate(0deg);
      }

      100% {
      transform: scale(2) rotate(590deg);
      }
    }

    @-webkit-keyframes scaletrans {
      0% {
      transform: scale(1) rotate(0deg);
      }

      100% {
      transform: scale(2) rotate(590deg);
      }
    }
    }
  </style>
</head>

<body class="h-style">
  <div id="upload-section">
    <div class="h-padded">
      <div class="h-flex h-flex--column">
        <div>
          <h1>BackTesting</h1>
          <p>
            Export MT5 bars by using CTRL+U then go to Bars tab, filter the
            range and export, then upload it here:
          </p>
          <p>
            More info:
            <a target="_blank" href="https://myforex.com/en/mt5guide/export-historicaldata.html">Export Historical
              Data</a>
            <a target="_blank" href="https://www.mql5.com/en/forum/356227">Limited History Issue</a>
          </p>
        </div>
        <hr class="h-hr" />
        <label for="">Upload CSV bars</label>
        <div class="h-flex">
          <input type="file" id="csvFileInput" accept=".csv" class="h-input-effects" style="width: 80%"/>
          <button id="csvRefresh" title="Refresh" class="mybutton h-input-effects">
            <i class="fas fa-repeat"></i>
          </button>
        </div>
        <hr class="h-hr" />
        <div class="h-flex">
          <div class="h-form-group">
            <label for="prevDate">Prev</label>
            <button id="prevDate" title="Previous Date" class="mybutton h-input-effects" onclick="changeDate(-1)">
              <i class="fas fa-arrow-left"></i>
            </button>
          </div>
          <div class="h-form-group">
            <label for="NavigateTroughtDates">Navigate trought dates</label>
            <select id="NavigateTroughtDates" class="h-input-effects"></select>
          </div>
          <div class="h-form-group">
            <label for="nextDate">Next</label>
            <button id="nextDate" title="Next Date" class="mybutton h-input-effects" onclick="changeDate(1)">
              <i class="fas fa-arrow-right"></i>
            </button>
          </div>
        </div>
        <script>
          function changeDate(direction) {
            const select = document.getElementById('NavigateTroughtDates');
            let newIndex = select.selectedIndex + direction;
            // Ensure newIndex is within the bounds of the select options
            if (newIndex >= 0 && newIndex < select.options.length) {
              select.selectedIndex = newIndex;
              select.dispatchEvent(new Event('change'));
            }
          }
        </script>
        <!--hr class="h-hr" />
        <label for="">Hidder</label>
        <div class="h-flex">
          <button id="hidderReset" title="Restart" class="mybutton h-input-effects" onclick="hidderRestart()">
            <i class="fas fa-repeat"></i>
          </button>
          <button id="hidderNextCandle" title="Reveal Next Candle" class="mybutton h-input-effects"
            onclick="hidderNext()">
            <i class="fas fa-arrow-right"></i>
          </button>
        </div>
        <script>
          document.addEventListener('DOMContentLoaded', () => {
            const hidder = document.getElementById('hidder');
            const moveButton = document.getElementById('hidderNextCandle');
            let intervalId;

            function moveElement() {
              if (!hidder.style.left) {
                hidder.style.left = '800px';
              }
              hidder.style.left = parseInt(hidder.style.left, 10) + 10 + 'px';
            }

            moveButton.addEventListener('mousedown', () => {
              intervalId = setInterval(moveElement, 50);
            });

            moveButton.addEventListener('mouseup', () => {
              clearInterval(intervalId);
            });

            moveButton.addEventListener('mouseleave', () => {
              clearInterval(intervalId);
            });
          });

          function hidderRestart() {
            let hidder = document.getElementById('hidder');
            if (hidder.style.display === 'none') {
              hidder.style.display = 'block';
            } else {
              hidder.style.display = 'none';
            }
            hidder.style.left = "800px";
          }
        </script-->
        <hr class="h-hr" />
        <label for="colorSettingsTutorial">Customize the chart colors theme</label>
        <div>
            <select id="themeSelector" class="h-input-effects" onchange="applyTheme()">
              <option value="">-</option>
              <option value="?bullishColor=00FF00&bearishColor=FF0000">Green / Red</option>
              <option value="?bullishColor=0000FF&bearishColor=FF00FF">Blue / Magenta</option>
              <option value="?bullishColor=FFFF00&bearishColor=00FFFF">Yellow / Cyan</option>
              <option value="?bullishColor=00cdff&bearishColor=555555">Light Blue / Grey</option>
              <option value="?bullishColor=FF5500&bearishColor=444444">Volcanic</option>
            </select>

            <script>
            function applyTheme() {
              const themeSelector = document.getElementById('themeSelector');
              const selectedTheme = themeSelector.value;
              const currentUrl = window.location.href.split('?')[0];
              window.location.href = currentUrl + selectedTheme;
            }
            </script>
        </div>
        <hr class="h-hr" />
        <label for="backtesting-hour">CSV Data</label>
        <div>
          <textarea id="csvContent" rows="10" style="width: 100%"></textarea>
        </div>
      </div>
    </div>
  </div>
  <div class="tools">
    <button class="mybutton h-input-effects" data-anotation="RRBuy" title="RR Tool (Buy)" disabled>
      <i class="fas fa-ruler-combined"></i>
    </button>
    <button class="mybutton h-input-effects" data-anotation="RRSell" title="RR Tool (Sell)" disabled>
      <i class="fas fa-ruler-combined"></i>
    </button>
    <button class="mybutton h-input-effects" data-anotation="line" title="Line Tool" disabled>
      <i class="fas fa-grip-lines"></i>
    </button>
    <button class="mybutton h-input-effects" data-anotation="BOS" title="BOS Tool" disabled>
      <i class="fas fa-grip-lines"></i>
    </button>
    <button class="mybutton h-input-effects" data-anotation="Circle" title="Circle Tool" disabled>
      <i class="fas fa-circle"></i>
    </button>
    <button class="mybutton h-input-effects" data-anotation="rectangle" title="Rectangle Tool" disabled>
      <i class="fa-regular fa-square"></i>
    </button>
  </div>
  <div id="hidder"></div>
  <div class="chart-section">
    <div id="loading-element" class="loading-element">
      <span class="spinner"></span>
      Backtesting is loading ...
    </div>
    <div id="scichart-root"></div>
    <div id="result-panel" class="result-panel">
      <div class="result-panel-toolbar">
        <button id="result-panel-toolbar-content-toggler-algo-editor" class="mybutton h-input-effects result-panel-toolbar-toggler">
          Algo Editor
        </button>
        <button id="result-panel-toolbar-content-toggler-algo" class="mybutton h-input-effects result-panel-toolbar-toggler">
          Backtesting results (Algo)
        </button>
        <button id="result-panel-toolbar-content-toggler-review" class="mybutton h-input-effects result-panel-toolbar-toggler">
          Review From Historical Trades
        </button>
        <button disabled id="result-panel-toolbar-content-toggler-manual" class="mybutton h-input-effects result-panel-toolbar-toggler">
          Backtesting results (Manual)
        </button>
        <div class="spacer"></div>
        <button id="result-panel-toolbar-toggler" class="mybutton h-input-effects result-panel-toolbar-toggler">
          <span><i class="fas fa-arrow-up"></i></span>
          <span><i class="fas fa-arrow-down"></i></span>
        </button>
      </div>
      <div class="result-panel-content h-hide h-flex h-flex--column">
        <h3>Algo editor</h3>
        <div>
          The code field (textarea) below is completely customisable and runs on each candles draw, <br/>
          you can use multiple already made functions/variables and set debuggers in strategic spots. <br/>
          Your code below must require the following structure: <br/>
          <pre>
            <code>
// Some variables you can use:
let arrayOfSignals = [false, false]; // Represents 2 signals

... // Your code here

EnumActionType
  .VERTICAL_LINE
  .DRAW_A_CIRCLE
  .TAKE_A_TRADE
            </code>
          </pre>
        </div>
        <div class="h-flex">
          <textarea name="signal-condition" id="algoEditorTextareaMain0" width="100%" rows="3" style="width: 100%; white-space: nowrap;">
// Represents 2 signals:
arrayOfSignals.push(false);
arrayOfSignals.push(false);
          </textarea>
        </div>
        <div class="h-flex">
          <textarea name="signal-condition-1-code" id="algoEditorTextareaMain1" width="100%" rows="10" style="width: 100%; white-space: nowrap;">
const currentTime = hourMinutes();
const time1 = '10:10'
const time2 = '10:45'

// Check if the current time is within the trading window
if (currentTime >= time1 && currentTime <= time2) {
  arrayOfSignals[0] = true;
  
  // Ensure SignalSwingHighLow runs and updates the swingHighLowHistory
  if (SignalSwingHighLow()) {
    const swingHistory = swingHighLowHistory.slice(-2); // Get the last two swings
    
    if (swingHistory.length === 2) {
      const [firstSwing, secondSwing] = swingHistory;
      let tradeDirection = EnumDirection.BULL;

      if (
        (firstSwing.type === 'LOW' && secondSwing.type === 'LOW' && firstSwing.maxReachedPrice < secondSwing.maxReachedPrice) ||
        (firstSwing.type === 'HIGH' && secondSwing.type === 'HIGH' && firstSwing.maxReachedPrice > secondSwing.maxReachedPrice)
      ) {
        if (firstSwing.maxReachedPrice < secondSwing.maxReachedPrice) {
          tradeDirection = EnumDirection.BULL;
        }
        else if (firstSwing.maxReachedPrice > secondSwing.maxReachedPrice) {
          tradeDirection = EnumDirection.BEAR;
        }
        arrayOfSignals[0] = true; // Mark swing point detection signal as valid
        // Limit to one trade per trading window
        if (!arrayOfSignals[1]) {
          arrayOfSignals[1] = true;
          AddActionOnChart(
            candlesFromBuffer[selectedIndexForSelectedCandleForAnalisis],
            EnumActionType.TAKE_A_TRADE,
            tradeDirection,
          );
        }
      } else {
        arrayOfSignals[0] = false; // Reset signal if conditions are not met
      }
    }
  }
  
  // Add an additional time-based signal for the end of the trading window
  if (currentTime === time1) {
    AddActionOnChart(EnumActionType.VERTICAL_LINE);
  }
  if (currentTime === time2) {
    AddActionOnChart(EnumActionType.VERTICAL_LINE);
  }
} else {
  // Reset signals outside the time range
  arrayOfSignals[0] = false;
  arrayOfSignals[1] = false;
}
          
          </textarea>
        </div>
        <div>
          <hr class="h-hr">
        </div>
        <div class="h-flex" style="position: relative;">
          <pre><code data="chatGPT-container"></code></pre>
          <textarea width="100%" rows="5" style="width: 100%; white-space: nowrap;" name="promptAI" id="promptAI" placeholder="ASK AI to build a strategy and click on button ->"></textarea>
          <button id="chatGPTFloatingIconButtonForModal"></button>
          <script>
            document.getElementById('chatGPTFloatingIconButtonForModal').addEventListener('click', () => {
              const providedCode = document.getElementById('algoEditorTextareaMain1').value;
              const userInput = document.getElementById('promptAI').value;
              const prompt = `
                ${providedCode}

                The code I provided to you runs on each new candle drawn on chart, and the code will be user inserted (via textarea) to make different trading strategies.

                Some variables and functions already created / defined so no need to redefine them:
                arrayOfSignals is simply an array of boolean that represents a trading plan validation
                EnumActionType will be mostly used with AddActionOnChart(EnumActionType), it has the following values: VERTICAL_LINE, DRAW_A_CIRCLE, TAKE_A_TRADE.
                AddActionOnChart will run function to add anotations on chart or event actions like taking a trade (annotations and other logics for the app backtesting system I already made)
                hourMinutes() will return a string based on the current candle.time (candle is always available on each candle drawn)
                SignalSwingHighLow() this function detect a swing and add data on swingHighLowHistory object, here is the example of its object structure: {time: string, maxReachedPrice: number, type: string}
                SignalConditionFVG() this function detect fvgs and add data on fvgHistory object, here is the example of its object structure: {id: index, time: string, initialPrice: number, gapFinalPrice: number, middlePrice: number, direction: string, tested: boolean}

                Using some of my functions and variables I already created make a strategy based on the following (just show me the code):

                ${userInput}
              `;
              chatGPTRequest(prompt);
            });
          </script>
        </div>
        <!--div class="accordion">
          <div class="accordion-item">
            <div class="accordion-header" id="headingOne">
              <button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapseOne" aria-expanded="true" aria-controls="collapseOne">
                Signal Condition 1
              </button>
            </div>
            <div id="collapseOne" class="accordion-collapse collapse" aria-labelledby="headingOne" data-bs-parent="#accordionExample">
              <div class="accordion-body">
                <label for="signal-condition-1-code">Make sure to return a boolean value (that's what makes the signal to take trade), You can set a debugger / pause execution near SignalCondition2() function to see how it works and debug all variables:</label>
                <textarea name="signal-condition-1-code" id="algoEditorTextarea" width="100%" rows="10">hourMinutes() == '10:10';</textarea>
                <label for="signal-condition-1-annotation">Signal Display Type (Signal representation on chart after valid condition from above returned code):</label>
                <select name="signal-condition-1-annotation" id="signalCondition1Annotation">
                  <option value="vertical-line">Vertical Line</option>
                  <option value="draw-a-circle">Draw a circle</option>
                  <option value="take-a-trade">Take a Trade</option>
                </select>
              </div>
            </div>
          </div>
          <div class="accordion-item">
            <div class="accordion-header" id="headingTwo">
              <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseTwo" aria-expanded="false" aria-controls="collapseTwo">
                Signal Condition 2
              </button>
            </div>
            <div id="collapseTwo" class="accordion-collapse collapse" aria-labelledby="headingTwo" data-bs-parent="#accordionExample">
              <div class="accordion-body">
                <label for="signal-condition-2-code">Make sure to return a boolean value (that's what makes the signal to take trade), You can set a debugger / pause execution near SignalCondition2() function to see how it works and debug all variables:</label>
                <textarea name="signal-condition-2-code" id="algoEditorTextarea2" width="100%" rows="10">hourMinutes() == '10:45' && hourMinutes() >= '10:10'; // TODO: replace 'true' buy previous returned result</textarea>
                <label for="signal-condition-2-annotation">Signal Display Type (Signal representation on chart after valid condition from above returned code):</label>
                <select name="signal-condition-2-annotation" id="signalCondition2Annotation">
                  <option value="vertical-line">Vertical Line</option>
                  <option value="draw-a-circle">Draw a circle</option>
                  <option value="take-a-trade">Take a Trade</option>
                </select>
              </div>
            </div>
          </div>
          <div class="accordion-item">
            <div class="accordion-header" id="headingThree">
              <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseThree" aria-expanded="false" aria-controls="collapseThree">
                Signal Condition 3
              </button>
            </div>
            <div id="collapseThree" class="accordion-collapse collapse" aria-labelledby="headingThree" data-bs-parent="#accordionExample">
              <div class="accordion-body">
                <label for="signal-condition-3-code">Make sure to return a boolean value (that's what makes the signal to take trade), You can set a debugger / pause execution near SignalCondition2() function to see how it works and debug all variables:</label>
                <textarea name="signal-condition-3-code" id="algoEditorTextarea3" width="100%" rows="10">hourMinutes() == '10:45' && SignalCondition2(); // TODO: replace 'true' buy previous returned result</textarea>
                <label for="signal-condition-3-annotation">Signal Display Type (Signal representation on chart after valid condition from above returned code):</label>
                <select name="signal-condition-3-annotation" id="signalCondition3Annotation">
                  <option value="vertical-line">Vertical Line</option>
                  <option value="draw-a-circle">Draw a circle</option>
                  <option value="take-a-trade">Take a Trade</option>
                </select>
              </div>
            </div>
          </div>
        </div>
        <script>
          document.querySelectorAll('.accordion-button').forEach(button => {
            button.addEventListener('click', () => {
              const accordionItem = button.closest('.accordion-item');
              const collapseElement = accordionItem.querySelector('.accordion-collapse');

              if (collapseElement.classList.contains('show')) {
                collapseElement.style.height = `${collapseElement.scrollHeight}px`;
                setTimeout(() => {
                  collapseElement.style.height = '0';
                }, 0);
                collapseElement.classList.remove('show');
              } else {
                document.querySelectorAll('.accordion-collapse.show').forEach(openItem => {
                  openItem.style.height = '0';
                  openItem.classList.remove('show');
                });
                collapseElement.classList.add('show');
                collapseElement.style.height = `${collapseElement.scrollHeight}px`;
              }
            });
          });
        </script-->
      </div>
      <div class="result-panel-content h-flex h-flex--column">
        <h5 for="backtesting-hour">Backtesting Result (Algo)</h5>
        <div class="h-flex h-flex--row">
          <div class="h-flex h-flex--column">
            <div class="h-flex h-flex--column">
              <label for="backtesting-hour">Prefered Backtesting Hour (add 2h to match MT5 data)</label>
              <input id="backtesting-hour" class="h-input-effects" type="text" value="10:00:00" />
            </div>
            <div class="h-flex h-flex--column">
              <label for="LotSize">Lot Size</label>
              <input id="LotSize" type="number" value="1.0" class="h-input-effects" />
              <label for="">RR (SL Points | TP Points)</label>
              <input id="SLPoints" type="number" value="0.0001" class="h-input-effects" />
              <input id="TPPoints" type="number" value="0.0003" class="h-input-effects" />
            </div>
          </div>
          <textarea id="backtestingResult" rows="10" style="flex-grow: 1; min-width: 20%" class="h-field"></textarea>
          <div id="myChartContainer" styles="flex-grow: 3; width: 700px">
            <canvas id="myChart" width="700px" height="300px"></canvas>
          </div>
        </div>
        <div>
          <div id="backtestingResultOrderHistory" class="h-field"></div>
        </div>
      </div>
      <div class="result-panel-content h-flex h-flex--column">
        <h5 for="backtesting-hour">Review Historical Trade</h5>
        <div class="h-flex h-flex--row">
          <div class="h-flex h-flex--column">
            <label for="textareaHistoricalTradesLines">Paste your historical lines (myfxbook for now)</label>
            <textarea id="textareaHistoricalTradesLines" rows="10" style="flex-grow: 1; min-width: 600px" class="h-field">05.13.2025 10:17	05.13.2025 10:18	EURUSD	Sell	1.00	1.11078	-	1.11064	1.11078	-1.4	-16.60	1m	-0.03%	-4.0000</textarea>
          </div>
        </div>
        <div>
          <div id="backtestingResultOrderHistory" class="h-field"></div>
        </div>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/scichart/index.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
  <script>
    // Result Panel Related Actions / Triggers:
    const resultPanel = document.querySelector('#result-panel');
    const $csvRefresh = document.querySelector('#csvRefresh');
    const $csvDataField = document.getElementById('csvContent');
    const $csvFileInput = document.getElementById('csvFileInput');
    const toolbarToggler = document.querySelector('#result-panel-toolbar-toggler');
    const $navigateTroughtDates = document.getElementById('NavigateTroughtDates');
    const $textareaHistoricalTradesLines = document.getElementById('textareaHistoricalTradesLines');
    function toggleHeight() {
      resultPanel.classList.toggle('active');
    }
    toolbarToggler.addEventListener('click', toggleHeight);

    document.getElementById('result-panel-toolbar-content-toggler-algo-editor').addEventListener('click', () => {
      resultPanel.classList.add('active');
      document.querySelectorAll('.result-panel-content')[0].classList.remove('h-hide');
      document.querySelectorAll('.result-panel-content')[1].classList.add('h-hide');
      document.querySelectorAll('.result-panel-content')[2].classList.add('h-hide');
    });

    document.getElementById('result-panel-toolbar-content-toggler-algo').addEventListener('click', () => {
      resultPanel.classList.add('active');
      document.querySelectorAll('.result-panel-content')[0].classList.add('h-hide');
      document.querySelectorAll('.result-panel-content')[1].classList.remove('h-hide');
      document.querySelectorAll('.result-panel-content')[2].classList.add('h-hide');
    });

    document.getElementById('result-panel-toolbar-content-toggler-review').addEventListener('click', () => {
      resultPanel.classList.add('active');
      document.querySelectorAll('.result-panel-content')[0].classList.add('h-hide');
      document.querySelectorAll('.result-panel-content')[1].classList.add('h-hide');
      document.querySelectorAll('.result-panel-content')[2].classList.remove('h-hide');
    });

    $csvRefresh.addEventListener('click', () => {
      const file = $csvFileInput.files[0];
      handleFileAndInitGraph(file);
    });

    $textareaHistoricalTradesLines.addEventListener('change', () => {
      const lines = $textareaHistoricalTradesLines.value.split(',');
      const trades = lines.map(line => {
        const parts = line.split('\t');

        /*  Actual example format :
            Open Date	Close date	Symbol	Action	Lots	SL (Price)	TP (Price)	Open Price	Close Price	Pips	Net Profit	Duration	Gain	Commissions
            05.13.2025 10:17	05.13.2025 10:18	EURUSD	Sell	1.00	1.11078	-	1.11064	1.11078	-1.4	-16.60	1m	-0.03%	-4.0000		
        */

        return {
            openedTradeDateTime: parts[0],
            closedTradeDateTime: parts[1],
            symbol: parts[2],
            orderDirection: parts[3],
            lotSize: parseFloat(parts[4]),
            slPrice: parts[5] === '-' ? null : parseFloat(parts[5]),
            tpPrice: parts[6] === '-' ? null : parseFloat(parts[6]),
            entryPrice: parseFloat(parts[7]),
            closePrice: parseFloat(parts[8]),
            pnlPips: parseFloat(parts[9]),
            pnlPrice: parseFloat(parts[10]),
            tradeDuration: parts[11],
            pnlPercent: parseFloat(parts[12]),
            commission: parseFloat(parts[13]),
        };
      });
      
      
    });


    /* ---- */

    const decimals = 5;
    let candlesFromBuffer = [];
    const MAX_BUFFER_SIZE = 10;
    let slSize = () => parseFloat(document.getElementById('SLPoints').value);
    let tpSize = () => parseFloat(document.getElementById('TPPoints').value);
    let lotSize = () => parseFloat(document.getElementById('LotSize').value);
    let bullishColor = '00FF00';
    let bearishColor = 'FF0000';
    let greyColor = '999999';
    const EnumDirection = {
      BULL: 'BULL',
      BEAR: 'BEAR',
    };
    const EnumOrderStatus = {
      PENDING: 'PENDING',
      CLOSED_BY_TP: 'CLOSED_BY_TP',
      CLOSED_BY_SL: 'CLOSED_BY_SL',
    };
    const EnumActionType = {
      VERTICAL_LINE: 'VERTICAL_LINE',
      DRAW_A_CIRCLE: 'DRAW_A_CIRCLE',
      TAKE_A_TRADE: 'TAKE_A_TRADE',
    };
    const EnumOHLC = {
      TIME: 0,
      OPEN: 1,
      HIGH: 2,
      LOW: 3,
      CLOSE: 4,
    };

    const getCandleDirection = (candle) => {
      return candle[4] > candle[1] ? EnumDirection.BULL : EnumDirection.BEAR;
    };

    const getCandleChartAxisLocationFromDate = (date) => {
      return new Date(date).getTime() / 1000;
    };

    // Window assignments:
    window.getCandleChartAxisLocationFromDate = getCandleChartAxisLocationFromDate;

    function formatDateFromUnix(unixTime) {
      const options = {
        year: 'numeric',
        month: 'numeric',
        day: 'numeric',
        hour: '2-digit',
        minute: '2-digit',
        // second: '2-digit',
        hour12: false,
      };
      return new Date(unixTime * 1000).toLocaleDateString('en-GB', options); // Multiply by 1000 to convert to milliseconds because JS Date works with milliseconds.
    }

    // Handy function to execute actions step by step:
    const stepByStep = (step, actions) => {
      return actions[step - 1]();
    };

    const convertMT5DateToUnix = (candleTime) => {
      const ct = candleTime.replaceAll('.','-');
      return new Date(ct).getTime() / 1000; // - 3600 * 2; // divided by 1000 to convert from milliseconds to seconds as Unix time only accepts seconds, while JS Date is more precise as working with milliseconds.
    };

    initSciChart();

    const applyTimeout = false; // TODO: Currenlty not working as expected, need to fix it
    
    const csvData = [];
    let csvDataIndex = 0;
    let numbDays = 0;
    let ordersHistory = [];
    window.ordersHistory = ordersHistory;

    const handleFileAndInitGraph = (file) => {
      if (file) {
        clearAndDeleteChart();

        // Clear orders history
        ordersHistory = [];
        numbDays = 0;

        // Reset portfolio graph and order history display
        document.getElementById('backtestingResult').value = '';
        document.getElementById('backtestingResultOrderHistory').innerHTML = '';

        // add visible class to loading element
        document.getElementById('loading-element').classList.add('visible');
        
        Papa.parse(file, {
          header: true,
          dynamicTyping: true,
          //worker: true,
            step: function (results, parser) {
              const row = results.data;
              csvDataIndex += 1;
              if (applyTimeout) {
                setTimeout(() => {
                appendDataToChart(results.data, csvDataIndex);
                }, csvDataIndex * 1000); // Adjust the delay as needed (1000ms per step)
              } else {
                appendDataToChart(results.data, csvDataIndex);
              }
            },
          complete: function (results, file) {
            //console.log("Parsing complete:", results, file);
            //const content = csvData;
            //document.getElementById('csvContent').value = JSON.stringify(csvData, null, 2);
            //initSciChart(csvData);
            profitabilityCalculation();
            // remove visible class to loading element
            document.getElementById('loading-element').classList.remove('visible');
          },
          error: function (error) {
            console.error('Error parsing CSV:', error);
          }
        });
        document.getElementById('result-panel-toolbar-content-toggler-algo').click();
      }
    };

    $csvFileInput.addEventListener('change', function loadcsv (event) {
      const file = event.target.files[0];
      handleFileAndInitGraph(file);
    });

    // Define the initSciChart function
    function initSciChart(data) {
      const {
        SciChartSurface,
        NumericAxis,
        FastCandlestickRenderableSeries,
        OhlcDataSeries,
        SciChartJsNavyTheme,
        SciChartJSDarkv2Theme,
        NumberRange,
        MouseWheelZoomModifier,
        ZoomPanModifier,
        ZoomExtentsModifier,
        YAxisDragModifier,
        XAxisDragModifier,
        DateTimeNumericAxis,
        DateLabelProvider,
        EDragMode,
        CursorModifier,
        BoxAnnotation,
        ECoordinateMode,
        getCanvasCoordinatesFromEvent,
        VerticalLineAnnotation,
        SolidColorBrush,
        Colors,
        ELabelPlacement,
        EAnnotationLayer,
        DateRange,
        EAutoRange,
        LineAnnotation,
        AxisMarkerAnnotation,
        CustomAnnotation,
        EVerticalAnchorPoint,
        EHorizontalAnchorPoint,
        ENumericFormat,
        EDateFormatter,
        Point,
        FastLineRenderableSeries,
        XyDataSeries,
        // GlowEffect,
        // ShadowEffect,
      } = SciChart;

      // Tell SciChart where to get webassembly files from.
      SciChartSurface.useWasmFromCDN();

      // Initialize SciChartSurface. Don't forget to await!
      SciChartSurface.create('scichart-root', {
        theme: new SciChartJsNavyTheme(),
      })
        .then(({ sciChartSurface, wasmContext }) => {
          // Extract URL parameters
          const urlParams = new URLSearchParams(window.location.search);
          bullishColor = decodeURIComponent(urlParams.get('bullishColor') || bullishColor);
          bearishColor = decodeURIComponent(urlParams.get('bearishColor') || bearishColor);
          
          // Create a custom theme by implementing all the properties from IThemeProvider
          const customTheme = {
            axisBorder: 'Transparent',
            axisTitleColor: '#111',
            annotationsGripsBackroundBrush: 'white',
            annotationsGripsBorderBrush: 'white',
            axis3DBandsFill: '#1F3D6833',
            axisBandsFill: '#1F3D6833',
            axisPlaneBackgroundFill: 'Transparent',
            columnFillBrush: 'white',
            columnLineColor: 'Transparent',
            cursorLineBrush: '#111',
            downBandSeriesFillColor: '#52CC5490',
            downBandSeriesLineColor: '#E26565FF',
            downBodyBrush: bearishColor, // candle
            downWickColor: bearishColor, // candle
            gridBackgroundBrush: 'white',
            gridBorderBrush: 'white',
            labelForegroundBrush: '#EEEEEE',
            legendBackgroundBrush: '#1D2C35',
            lineSeriesColor: 'white',
            loadingAnimationBackground: '#111',
            loadingAnimationForeground: '#111',
            majorGridLineBrush: '#111',
            minorGridLineBrush: '#111',
            mountainAreaBrush: 'white',
            mountainLineColor: 'white',
            overviewFillBrush: 'white',
            planeBorderColor: 'white',
            rolloverLineBrush: '#FD9F2533',
            rubberBandFillBrush: '#99999933',
            rubberBandStrokeBrush: '#99999977',
            sciChartBackground: '#000', // Chart background color
            scrollbarBackgroundBrush: 'white',
            scrollbarBorderBrush: 'white',
            scrollbarGripsBackgroundBrush: 'white',
            scrollbarViewportBackgroundBrush: 'white',
            scrollbarViewportBorderBrush: 'white',
            shadowEffectColor: 'white',
            textAnnotationBackground: '#333',
            textAnnotationForeground: '#EEEEEE',
            tickTextBrush: '#333',
            upBandSeriesFillColor: 'white',
            upBandSeriesLineColor: 'white',
            upBodyBrush: bullishColor, // candle
            upWickColor: bullishColor, // candle
          };
          sciChartSurface.applyTheme(customTheme);

          window.sciChartSurface = sciChartSurface;

          // Cursor labels:
          const growBy = new NumberRange(0.2, 0.2);
          const xAxis = new DateTimeNumericAxis(wasmContext, { growBy });
          xAxis.labelProvider.formatCursorLabel = (dataValue) => {
            const unixDateStamp = Math.floor(dataValue); // Flooring it to remove milliseconds from that cursor data, as it is too much precise // - 3600;
            return formatDateFromUnix(unixDateStamp);
          };
          const yAxis = new NumericAxis(wasmContext, {
            labelPrecision: decimals,
            autoRange: EAutoRange.Once,
            // visibleRangeLimit: new NumberRange(1.02, 1.03),
            growBy,
          });

          sciChartSurface.xAxes.add(xAxis);
          sciChartSurface.yAxes.add(yAxis);

          console.log("scichart yaxis started");

          // Variables initialization:
          let annotations = [];

          // Create an XAxis and YAxis with growBy padding
          // sciChartSurface.xAxes.add(new NumericAxis(wasmContext, { axisTitle: "Time", growBy }));
          // sciChartSurface.yAxes.add(new NumericAxis(wasmContext, { axisTitle: "Price", growBy }));

          const signalAnnotation = {
            svgString: {
              buy: '<svg id="Capa_1" xmlns="http://www.w3.org/2000/svg" width="10" height="10" viewBox="0 0 10 10"><g transform="translate(-54.616083,-75.548914)"><path style="fill:#0000FF;" d="M 55,85 L 60,75 L 65,85 Z"/></g></svg>',
              bullish: '<svg id="Capa_1" xmlns="http://www.w3.org/2000/svg" width="10" height="10" viewBox="0 0 10 10"><g transform="translate(-54.616083,-75.548914)"><path style="fill:#00FF00;" d="M 55,85 L 60,75 L 65,85 Z"/></g></svg>',
              sell: '<svg id="Capa_1" xmlns="http://www.w3.org/2000/svg" width="10" height="10" viewBox="0 0 10 10"><g transform="translate(-54.616083,-75.548914)"><path style="fill:#FF0000;" d="M 55,75 L 60,85 L 65,75 Z"/></g></svg>',
              bearish: '<svg id="Capa_1" xmlns="http://www.w3.org/2000/svg" width="10" height="10" viewBox="0 0 10 10"><g transform="translate(-54.616083,-75.548914)"><path style="fill:#FF0000;" d="M 55,75 L 60,85 L 65,75 Z"/></g></svg>',
              circle: `<svg id="Capa_1" xmlns="http://www.w3.org/2000/svg"><circle cx="10" cy="10" r="8" style="fill:#${bullishColor};fill-opacity:0.34117647;stroke:#${bullishColor};stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1" /></svg>`,
            },
          };

          const RRToolStyles = {
            strokeThickness: 0,
            xCoordinateMode: ECoordinateMode.DataValue,
            yCoordinateMode: ECoordinateMode.DataValue,
            annotationLayer: EAnnotationLayer.AboveChart,
            opacity: '50',
          };

          function ceilToDecimalPlaces(num, decimalPlaces) {
            const factor = Math.pow(10, decimalPlaces); // Calculate 10^decimalPlaces
            return Math.ceil(num * factor) / factor; // Ceil and then divide
          }

          // Function to update Y-axis range dynamically
          function updateYAxisRange() {
            const yMin = 1.034; // ohlcDataSeries.getNativeYMin();
            const yMax = 1.042; // ohlcDataSeries.getNativeYMax();

            sciChartSurface.yAxes.get(0).visibleRangeLimit = new NumberRange(yMin, yMax);
          }

          // AddActionOnChart: ========================================
            // Function to create annotations or take actions on the chart, based on UI selected options:
            const AddActionOnChart = (candle, EnumActionType, tradeDirection = EnumDirection.BULL) => {
              const candlePosition = convertMT5DateToUnix(candle[EnumOHLC.TIME]);
              switch (EnumActionType) {
                case 'VERTICAL_LINE':
                  sciChartSurface.annotations.add(
                    new VerticalLineAnnotation({
                      x1: candlePosition,
                      stroke: `#${bullishColor}`,
                      strokeThickness: 1,
                    })
                  );
                  break;
                case 'DRAW_A_CIRCLE':
                  sciChartSurface.annotations.add(
                    new CustomAnnotation({
                      x1: candlePosition,
                      y1: candle[EnumOHLC.CLOSE],
                      verticalAnchorPoint: EVerticalAnchorPoint.Center,
                      horizontalAnchorPoint: EHorizontalAnchorPoint.Center,
                      svgString: signalAnnotation.svgString.circle,
                    })
                  );
                  break;
                case 'TAKE_A_TRADE':
                  const orderOptionsBasedDirection = (tradeDirection) => {
                    if (tradeDirection == EnumDirection.BULL) {
                      return {
                        sl: candle[EnumOHLC.CLOSE] - slSize(),
                        tp: candle[EnumOHLC.CLOSE] + tpSize(),
                        direction: EnumDirection.BULL,
                      };
                    } else {
                      return {
                        sl: candle[EnumOHLC.CLOSE] + slSize(),
                        tp: candle[EnumOHLC.CLOSE] - tpSize(),
                        direction: EnumDirection.BEAR,
                      };
                    }
                  };
                  // Add order to history:
                  ordersHistory.push({
                    id: ordersHistory.length + 1,
                    time: candle[EnumOHLC.TIME],
                    price: candle[EnumOHLC.CLOSE],
                    orderStatus: EnumOrderStatus.PENDING,
                    ...orderOptionsBasedDirection(tradeDirection),
                  });

                  window.ordersHistory = ordersHistory;

                  // Add annotation from entry:
                  sciChartSurface.annotations.add(
                    new CustomAnnotation({
                      x1: candlePosition,
                      y1: candle[EnumOHLC.CLOSE],
                      verticalAnchorPoint: EVerticalAnchorPoint.Center,
                      horizontalAnchorPoint: EHorizontalAnchorPoint.Center,
                      svgString: signalAnnotation.svgString.buy,
                    })
                  );
                  break;
              }
            }
          // End of AddActionOnChart ========================================

          // For testing purposes:
          const rdata = [
            ['2021.06.29', '00:00:00', 1.23456, 1.23456, 1.23456, 1.23456],
            ['2021.06.29', '00:01:00', 1.23456, 1.23456, 1.23456, 1.23456],
            ['2021.06.29', '00:02:00', 1.23456, 1.23456, 1.23456, 1.23456],
            ['2021.06.29', '00:03:00', 1.23456, 1.23456, 1.23456, 1.23456],
            ['2021.06.29', '00:04:00', 1.23456, 1.23456, 1.23456, 1.23456],
            ['2021.06.29', '00:05:00', 1.23456, 1.23456, 1.23456, 1.23456],
            ['2021.06.29', '00:06:00', 1.23456, 1.23456, 1.23456, 1.23456],
            ['2021.06.29', '00:07:00', 1.23456, 1.23456, 1.23456, 1.23456],
            ['2021.06.29', '00:08:00', 1.23456, 1.23456, 1.23456, 1.23456],
            ['2021.06.29', '00:09:00', 1.23456, 1.23456, 1.23456, 1.23456],
            ['2021.06.29', '00:10:00', 1.23456, 1.23456, 1.23456, 1.23456],
            ['2021.06.29', '00:11:00', 1.23456, 1.23456, 1.23456, 1.23456],
          ];

          // Parse CSV content
          //const rows = null; //data.trim().split('\r\n'); // Split by lines
          //const header = rows[0].split('\t'); // Extract headers
          //const rdata = rows.slice(1).map((row) => row.split('\t')); // Split rows into fields

          const ohlcData = rdata.map((row) => {
            /*https://developers.binance.com/docs/binance-spot-api-docs/rest-api#klinecandlestick-data*/
            /*
              return {
                time: row[0],
                open: parseFloat(row[1]),
                high: parseFloat(row[2]),
                low: parseFloat(row[3]),
                close: parseFloat(row[4])
              }
            */

            /* MT5 exported CSV format: */
            return {
              time: `${row[0]} ${row[1]}`,
              open: parseFloat(row[2]),
              high: parseFloat(row[3]),
              low: parseFloat(row[4]),
              close: parseFloat(row[5]),
            };
          });
          
          let canTakeATrade = true;
          let inRange = false;
          let swingHighLowHistory = [];
          let fvgHistory = [];
          let rollingHighestHighDataSeries = null;
          let rollingLowestLowDataSeries = null;
          const minDate = new Date(ohlcData[0].time);
          const maxDate = new Date(ohlcData[ohlcData.length - 1].time);
          const offsetCandleDateTimeStamp = (candleDateTimeStamp) => candleDateTimeStamp; // - 3600 * 1; // !! offseting candle position in X axis by -1h to match tradingView (The correct way would be to offset the axis labels, but dont know how to do it yet)

          // First function to be executed as soon as the data is loaded, you can do anything you want here:
          const onData = (ohlcData) => {
            // console.log('ohlcData:', ohlcData);
          }

          // Second function to be executed after the candle is drawn, you can add annotations here:
          const onCandleDrawn = (candle, index, candlesFromBuffer) => {
            const algoEditorTextareaMain0 = document.getElementById('algoEditorTextareaMain0');
            const algoEditorTextareaMain1 = document.getElementById('algoEditorTextareaMain1');
            const hourMinutes = () => candle[0].split(' ')[1].slice(0, 5);
            let arrayOfSignals = [];
            const candlePosition = convertMT5DateToUnix(candle[0]);
            const prevCandle = ohlcData[index - 1];
            const nextCandle = ohlcData[index + 1];

            // candle[0] === "2025.01.10 21:10:00" && AddActionOnChart(candle, EnumActionType.VERTICAL_LINE);

            // TP/SL Validation: ========================================
              // Check for tp/sl hit:
              ordersHistory.forEach((order) => {
                switch (order.direction) {
                  case EnumDirection.BULL:
                    if (candle[EnumOHLC.HIGH] >= order.tp && !order.closed) {

                      order.closed = true;
                      order.closedPrice = order.tp;
                      order.closedTime = candle[EnumOHLC.TIME];
                      order.orderStatus = EnumOrderStatus.CLOSED_BY_TP,

                      sciChartSurface.annotations.add(
                        new CustomAnnotation({
                          x1: convertMT5DateToUnix(order.closedTime),
                          y1: order.tp,
                          verticalAnchorPoint: EVerticalAnchorPoint.Center,
                          horizontalAnchorPoint: EHorizontalAnchorPoint.Center,
                          svgString: signalAnnotation.svgString.sell,
                        })
                      );
                      sciChartSurface.annotations.add(
                        new LineAnnotation({
                          stroke: `#${greyColor}`,
                          strokeThickness: 1,
                          strokeDashArray: [5, 5],
                          x1: convertMT5DateToUnix(order.time),
                          x2: convertMT5DateToUnix(order.closedTime),
                          y1: order.price,
                          y2: order.closedPrice,
                        })
                      );
                    }
                    if (candle[EnumOHLC.LOW] <= order.sl && !order.closed) {

                      order.closed = true;
                      order.closedPrice = order.sl;
                      order.closedTime = candle[EnumOHLC.TIME];
                      order.orderStatus = EnumOrderStatus.CLOSED_BY_SL,

                      sciChartSurface.annotations.add(
                        new CustomAnnotation({
                          x1: convertMT5DateToUnix(order.closedTime),
                          y1: order.sl,
                          verticalAnchorPoint: EVerticalAnchorPoint.Center,
                          horizontalAnchorPoint: EHorizontalAnchorPoint.Center,
                          svgString: signalAnnotation.svgString.sell,
                        })
                      );
                      sciChartSurface.annotations.add(
                        new LineAnnotation({
                          stroke: `#${greyColor}`,
                          strokeThickness: 1,
                          strokeDashArray: [5, 5],
                          x1: convertMT5DateToUnix(order.time),
                          x2: convertMT5DateToUnix(order.closedTime),
                          y1: order.price,
                          y2: order.closedPrice,
                        })
                      );
                    }
                    break;
                  case EnumDirection.BEAR:
                    if (candle[EnumOHLC.LOW] <= order.tp && !order.closed) {

                      order.closed = true;
                      order.closedPrice = order.tp;
                      order.closedTime = candle[EnumOHLC.TIME];
                      order.orderStatus = EnumOrderStatus.CLOSED_BY_TP,

                      sciChartSurface.annotations.add(
                        new CustomAnnotation({
                          x1: convertMT5DateToUnix(order.closedTime),
                          y1: order.tp,
                          verticalAnchorPoint: EVerticalAnchorPoint.Center,
                          horizontalAnchorPoint: EHorizontalAnchorPoint.Center,
                          svgString: signalAnnotation.svgString.sell,
                        })
                      );
                      sciChartSurface.annotations.add(
                        new LineAnnotation({
                          stroke: `#${greyColor}`,
                          strokeThickness: 1,
                          strokeDashArray: [5, 5],
                          x1: convertMT5DateToUnix(order.time),
                          x2: convertMT5DateToUnix(order.closedTime),
                          y1: order.price,
                          y2: order.closedPrice,
                        })
                      );
                    }
                    if (candle[EnumOHLC.HIGH] >= order.sl && !order.closed) {

                      order.closed = true;
                      order.closedPrice = order.sl;
                      order.closedTime = candle[EnumOHLC.TIME];
                      order.orderStatus = EnumOrderStatus.CLOSED_BY_SL,

                      sciChartSurface.annotations.add(
                        new CustomAnnotation({
                          x1: convertMT5DateToUnix(order.closedTime),
                          y1: order.sl,
                          verticalAnchorPoint: EVerticalAnchorPoint.Center,
                          horizontalAnchorPoint: EHorizontalAnchorPoint.Center,
                          svgString: signalAnnotation.svgString.sell,
                        })
                      );
                      sciChartSurface.annotations.add(
                        new LineAnnotation({
                          stroke: `#${greyColor}`,
                          strokeThickness: 1,
                          strokeDashArray: [5, 5],
                          x1: convertMT5DateToUnix(order.time),
                          x2: convertMT5DateToUnix(order.closedTime),
                          y1: order.price,
                          y2: order.closedPrice,
                        })
                      );
                    }
                    break;
                }
              });
            // End of TP/SL Validation ========================================

            // FVG Related: ========================================
              // Check for FVG tested:
              fvgHistory.forEach((fvg) => {
                if (fvg.tested) return;
                // Check if wick candle is within the FVG range (currently too much perfectionism here it might reduce the quantity of signals):
                const testBullishFVG = candle.low > fvg.initialPrice && candle.low < fvg.gapFinalPrice;
                const testBearishFVG = candle.high < fvg.initialPrice && candle.high > fvg.gapFinalPrice;
                if ((testBullishFVG || testBearishFVG) && !fvg.tested) { // At this point we confirmly tested the FVG
                  fvg.tested = true;
                  // console.log('FVG / Candle', fvg, candle);
                }
              });

              // A FVG signal:
              /*
              const fvgExtent = 8;
              let isBullishFVG = false;
              let isBearishFVG = false;

              const SignalConditionFVG = () => {
                if (index < 3 || index > ohlcData.length - (fvgExtent + 1)) return false;
                isBullishFVG = nextCandle.low > prevCandle.high;
                isBearishFVG = prevCandle.low > nextCandle.high;

                return isBullishFVG || isBearishFVG;
              };

              if (SignalConditionFVG()) {
                const initialPrice = isBullishFVG ? prevCandle.high : prevCandle.low;
                const gapFinalPrice = isBullishFVG ? nextCandle.low : nextCandle.high;
                const differencial = Math.abs(nextCandle.low - prevCandle.high) / 2;

                // Calculate the middle price and round it to 5 decimal places
                const middlePrice = ceilToDecimalPlaces(initialPrice + differencial, 5);

                fvgHistory.push({
                  id: index,
                  time: candle[0],
                  initialPrice: initialPrice,
                  gapFinalPrice: gapFinalPrice,
                  middlePrice: middlePrice,
                  direction: getCandleDirection(candle) == 'BULL' ? EnumDirection.BULL : EnumDirection.BEAR,
                  tested: false,
                });

                /*sciChartSurface.annotations.add(
                  new BoxAnnotation({
                    x1: convertMT5DateToUnix(prevCandle.time),
                    x2: convertMT5DateToUnix(ohlcData[index + fvgExtent].time),
                    y1: getCandleDirection(candle) == 'BULL' ? prevCandle.high : prevCandle.low,
                    y2: getCandleDirection(candle) == 'BULL' ? nextCandle.low : nextCandle.high,
                    fill: `#${getCandleDirection(candle) == 'BULL' ? bullishColor : bearishColor}${RRToolStyles.opacity}`,
                    stroke: `#${getCandleDirection(candle) == 'BULL' ? bullishColor : bearishColor}`,
                    strokeThickness: 1,
                    opacity: 0.3,
                  })
                );
              }
              */
            // End of FVG Related ========================================
            
            // MSS Line Logic: ========================================
              /*
              function calculateRollingHighLow(ohlcData, lookbackPeriod) {
                const highPrices = ohlcData.map(data => data.close); // data.high
                const lowPrices = ohlcData.map(data => data.close); // data.low
                const rollingHighestHigh = [];
                const rollingLowestLow = [];
                for (let i = lookbackPeriod - 1; i < highPrices.length; i++) {
                  const highest = Math.max(...highPrices.slice(i - lookbackPeriod + 1, i + 1));
                  const lowest = Math.min(...lowPrices.slice(i - lookbackPeriod + 1, i + 1));
                  rollingHighestHigh.push(highest);
                  rollingLowestLow.push(lowest);
                }
                return { rollingHighestHigh, rollingLowestLow };
              }

              const signalCooldown = 4;
              const lookbackPeriod = 8;
              const slopeThreshold = 0.5;
              const times = ohlcData.map(data => convertMT5DateToUnix(data[0]));
              const { rollingHighestHigh, rollingLowestLow } = calculateRollingHighLow(ohlcData, lookbackPeriod);
              let mssDetected = false;
              let newSignalAvailable = false;
              let bullishMSS = false;
              let bearishMSS = false;
              const highestHighLong = [];
              const lowestLowShort = [];
              let slopeHighestHighLong = 0;
              let slopeLowestLowShort = 0;

              // Calculate highest high and lowest low
              if (index >= lookbackPeriod) {
                const highPrices = ohlcData.slice(index - lookbackPeriod, index).map(candle => candle.close); // candle.high
                highestHighLong.push(Math.max(...highPrices));
                
                const lowPrices = ohlcData.slice(index - lookbackPeriod, index).map(candle => candle.close); // candle.low
                lowestLowShort.push(Math.min(...lowPrices));

                // Calculate slope:
                slopeHighestHighLong = (highestHighLong - highestHighLong[lookbackPeriod]) / lookbackPeriod
                slopeLowestLowShort = (lowestLowShort - lowestLowShort[lookbackPeriod]) / lookbackPeriod

                // Check for MSS breakout conditions (breakout of the highest high or lowest low && slope is less than threshold (consistency))
                bullishMSS = candle.close > highestHighLong[0]// && Math.abs(slopeHighestHighLong) < slopeThreshold
                bearishMSS = candle.close < lowestLowShort[0]// && Math.abs(slopeLowestLowShort) < slopeThreshold

                // console.log('-> ', candle.close , highestHighLong[0], bullishMSS,);

                // Cooldown logic
                let lastSignalBar = null;
                signalTriggered = bullishMSS || bearishMSS
                newSignalAvailable = !lastSignalBar || (index - lastSignalBar >= signalCooldown)

                if (signalTriggered && newSignalAvailable) {
                  lastSignalBar = index
                }

                showBullish = (bullishMSS && newSignalAvailable) ? true : false
                showBearish = (bearishMSS && newSignalAvailable) ? true : false

                if (hourMinutes() >= '10:10' && hourMinutes() <= '10:45') {
                  inRange = true;
                } else {
                  inRange = false;
                  canTakeATrade = true;
                }

                if (showBullish) {
                  //AddActionOnChart(EnumActionType.DRAW_A_CIRCLE);
                  if (inRange && canTakeATrade) {
                    AddActionOnChart(EnumActionType.TAKE_A_TRADE, EnumDirection.BULL);
                    canTakeATrade = false;
                  }
                } else if (showBearish) {
                  //AddActionOnChart(EnumActionType.DRAW_A_CIRCLE);
                  if (inRange && canTakeATrade) {
                    AddActionOnChart(EnumActionType.TAKE_A_TRADE, EnumDirection.BEAR);
                    canTakeATrade = false;
                  }
                }
              }
              
              /*
              if (candle.close >= rollingHighestHigh[index - lookbackPeriod + 1]) {
                AddActionOnChart(EnumActionType.DRAW_A_CIRCLE);
                AddActionOnChart(EnumActionType.TAKE_A_TRADE, EnumDirection.BULL);
                mssDetected = true;
              } else {
                mssDetected = false;
              }
              */

              // Create data series for rolling highest high and lowest low
              /*
              rollingHighestHighDataSeries = new XyDataSeries(wasmContext, {
                xValues: times.slice(lookbackPeriod - 1),
                yValues: rollingHighestHigh,
              });
              rollingLowestLowDataSeries = new XyDataSeries(wasmContext, {
                xValues: times.slice(lookbackPeriod - 1),
                yValues: rollingLowestLow,
              });
              */
            // End of MSS Line Logic ========================================

            eval(algoEditorTextareaMain0.value);

            /*
              const SignalCondition1 = () => {
                const algoEditorTextarea = document.getElementById('algoEditorTextarea');
                return eval(algoEditorTextarea.value);
              }

              if (SignalCondition1()) {
                AddActionOnChart('signalCondition1Annotation');
              }

              const SignalCondition2 = () => {
                const algoEditorTextarea = document.getElementById('algoEditorTextarea2');
                return eval(algoEditorTextarea.value);
              }

              if (SignalCondition2()) {
                AddActionOnChart('signalCondition2Annotation');
              }

              const SignalCondition3 = () => {
                const algoEditorTextarea = document.getElementById('algoEditorTextarea3');
                return eval(algoEditorTextarea.value);
              }

              if (SignalCondition3()) {
                AddActionOnChart('signalCondition3Annotation');
              }
            */

            // Swing High/Low Logic: ========================================
              let isSwingHigh = false;
              let isSwingLow = false;

              // Get 4 candles for swing analysis:
              // let candleBufferForAnalisis = candlesFromBuffer.slice(-4);
              const selectedIndexForSelectedCandleForAnalisis = candlesFromBuffer.length - 2;
              
              const swhlPrevCandle2 = candlesFromBuffer[selectedIndexForSelectedCandleForAnalisis - 2];
              const swhlPrevCandle = candlesFromBuffer[selectedIndexForSelectedCandleForAnalisis - 1];
              const selectedCandleForAnalisis = candlesFromBuffer[selectedIndexForSelectedCandleForAnalisis]; // selected candle for analysis is the 2nd last candle from the buffer, because the last candle is the current candle and we will analize the next candle
              const swhlNextCandle = candlesFromBuffer[selectedIndexForSelectedCandleForAnalisis + 1];

              const SignalSwingHighLow = () => {
                if (index < 4 /*|| index > candlesFromBuffer.length - 3*/) return false;

                // For swing high, current candle high is less than or equal to the previous candle high and the previous candle high is greater than the previous candle open:
                isSwingHigh = selectedCandleForAnalisis[EnumOHLC.HIGH] <= swhlPrevCandle[EnumOHLC.HIGH] && swhlPrevCandle2[EnumOHLC.OPEN] < swhlPrevCandle[EnumOHLC.OPEN] && selectedCandleForAnalisis[EnumOHLC.HIGH] >= swhlNextCandle[EnumOHLC.HIGH] && getCandleDirection(selectedCandleForAnalisis) == 'BEAR';
                // For swing low, current candle low is greater than or equal to the previous candle low and the previous candle low is less than the previous candle close:
                isSwingLow = selectedCandleForAnalisis[EnumOHLC.LOW] >= swhlPrevCandle[EnumOHLC.LOW] && swhlPrevCandle2[EnumOHLC.CLOSE] > swhlPrevCandle[EnumOHLC.CLOSE] && selectedCandleForAnalisis[EnumOHLC.LOW] <= swhlNextCandle[EnumOHLC.LOW] && getCandleDirection(selectedCandleForAnalisis) == 'BULL';
                
                return isSwingLow || isSwingHigh;
              }

              if (SignalSwingHighLow()) {
                swingHighLowHistory.push({
                  time: swhlPrevCandle[0],
                  maxReachedPrice: isSwingHigh ? selectedCandleForAnalisis[EnumOHLC.HIGH] : selectedCandleForAnalisis[EnumOHLC.LOW], // Represents the highest/lowest price that was reached.
                  type: isSwingHigh ? 'HIGH' : 'LOW', // Represents the type of the swing (HIGH or LOW) its the position and NOT the candle direction.
                });

                sciChartSurface.annotations.add(
                  new CustomAnnotation({
                    x1: convertMT5DateToUnix(selectedCandleForAnalisis[EnumOHLC.TIME]),
                    y1: isSwingHigh ? selectedCandleForAnalisis[EnumOHLC.HIGH] : selectedCandleForAnalisis[EnumOHLC.LOW],
                    verticalAnchorPoint: isSwingHigh ? EVerticalAnchorPoint.Bottom : EVerticalAnchorPoint.Top,
                    horizontalAnchorPoint: EHorizontalAnchorPoint.Center,
                    svgString: isSwingHigh ? signalAnnotation.svgString.bearish : signalAnnotation.svgString.bullish,
                  })
                );
              }
            // End of Swing High/Low Logic: ========================================

            eval(algoEditorTextareaMain1.value);

            // Backtesting dates ====================================
              let candleDateTime = candle[EnumOHLC.TIME]; // excepted format: "1970.01.01 00:00:00"
              let unixTime = convertMT5DateToUnix(candleDateTime); // format: 1624982400 for 2021-06-29 00:00:00
              let candleTime = candleDateTime.split(' ')[1]; // get the time from the date string (00:00:00)
              let backTestTime = getCandleChartAxisLocationFromDate(candleDateTime); // + 3600; // Actually the same as above (candleDateTimeStamp)

              var selectedTime = document.getElementById('backtesting-hour').value;

              if (candleTime == selectedTime) {
                numbDays = numbDays + 1;
                let btt = backTestTime; // * 1000;
                let formatedDate = formatDateFromUnix(btt);

                // Display Backtesting dates on the select element:
                $navigateTroughtDates.innerHTML += `<option value="${unixTime}">${candleDateTime}</option>`;

                // Backtesting line annotation:
                sciChartSurface.annotations.add(
                  new VerticalLineAnnotation({
                    stroke: '#999',
                    axisLabelFill: '#999',
                    strokeThickness: 1,
                    x1: unixTime,
                    showLabel: true,
                    labelPlacement: ELabelPlacement.TopLeft,
                    labelValue: `${candleDateTime}`,
                  })
                );
              }
            // End of Backtesting dates ====================================
          }

          const profitabilityCalculation = () => {
            const profitsInPoints = ordersHistory.reduce((acc, order) => {
              if (order.orderStatus == EnumOrderStatus.CLOSED_BY_TP) { return acc + tpSize(); }
              if (order.orderStatus == EnumOrderStatus.CLOSED_BY_SL) { return acc - slSize(); }
              return acc;
            }, 0);

            console.log('Orders History:', ordersHistory);
            const winRate = ordersHistory.length > 0 ? (ordersHistory.filter((order) => order.orderStatus == EnumOrderStatus.CLOSED_BY_TP).length / ordersHistory.length * 100).toFixed(2) : 0;
            const moneyEquivalent = ((profitsInPoints * (lotSize() * 10)) * 10000).toFixed(2);
            const result = `Check console for orders history\n\nTrade Taken: ${ordersHistory.length} (in ${numbDays} days)\nWin Rate: ${winRate}% \n\nProfits: \n Money: ${moneyEquivalent}$\n Points: ${profitsInPoints.toFixed(5)} \n Pips: ${(profitsInPoints / 0.00010).toFixed(2)} \n Ticks: ${(profitsInPoints / 0.01).toFixed(2)}`;
            document.getElementById('backtestingResult').value = result;
  
            // Profitability Chart: ========================================
              let myChart = document.getElementById('myChart');
              var ctx = myChart.getContext('2d');
              var datasets = [];
              var values = ordersHistory.map((order) => {
                const pnlvar = order.orderStatus == EnumOrderStatus.CLOSED_BY_TP ? tpSize() : -slSize();
                return [pnlvar];
              });
              var labels = ordersHistory.map((order) => order.id);

              const pnlsum = () => {
                let sum = 0;
                return values.map((value) => {
                  var a = (sum += parseFloat(value));
                  return a;
                });
              };

              const equityPnL = () => {
                let equitySum = 0;
                const commission = 0.00005; // TODO: Currently high for testing and handicap the results
                return values.map((value) => {
                  var a = (equitySum += parseFloat(value - commission));
                  return a;
                });
              };

              // Check if there is an existing chart instance and destroy it:
              if (typeof myChart !== 'undefined' && myChart !== null) {
                myChart.remove();
                const newCanvas = document.createElement('canvas');
                newCanvas.id = 'myChart';
                newCanvas.width = 700;
                newCanvas.height = 300;
                document.getElementById('myChartContainer').appendChild(newCanvas);
                myChart = document.getElementById('myChart');
                ctx = myChart.getContext('2d');
                //myChart.destroy();
              }

              gradient = ctx.createLinearGradient(0, 25, 0, 300);
              gradient.addColorStop(0, `#${bullishColor}${RRToolStyles.opacity}`);
              gradient.addColorStop(1, `#${bearishColor}${RRToolStyles.opacity}`);

              datasets.push({
                type: 'line',
                label: 'Strategy Performance (Accumulated Points)',
                data: pnlsum(),
                borderColor: `#${bullishColor}`,
                backgroundColor: gradient,
                borderWidth: 1,
                order: 0,
                fill: true,
              });

              datasets.push({
                type: 'line',
                label: 'Portfolio Performance (Equity Curve)',
                data: equityPnL(),
                borderColor: `#${bearishColor}`,
                borderWidth: 1,
                order: 1,
                fill: false,
                tension: .5,
                pointStyle: false,
              });
              
              const profitabilityChartOptions = {
                //animation,
                responsive: false,
                elements: {
                  point: {
                    radius: 1,
                  },
                },
                scales: {
                  y: {
                    beginAtZero: false,
                  },
                },
              };

              myChart = new Chart(ctx, {
                type: 'line',
                data: {
                  labels: labels,	
                  datasets: datasets,
                },
                options: profitabilityChartOptions,
              });
              
              document.getElementById('backtestingResultOrderHistory').innerHTML = `
                <table>
                  <thead>
                    <tr>
                      <th>ID</th>
                      <th>Time</th>
                      <th>Price</th>
                      <th>SL</th>
                      <th>TP</th>
                      <th>Direction</th>
                      <th>Order Status</th>
                      <th>Closed Price</th>
                      <th>Closed Time</th>
                    </tr>
                  </thead>
                  <tbody>
                    ${ordersHistory.map(order => `
                      <tr>
                        <td>${order.id}</td>
                        <td>${order.time}</td>
                        <td>${order.price.toFixed(5)}</td>
                        <td>${order.sl.toFixed(5)}</td>
                        <td>${order.tp.toFixed(5)}</td>
                        <td>${order.direction}</td>
                        <td>${order.orderStatus}</td>
                        <td>${order.closedPrice || ''}</td>
                        <td>${order.closedTime || ''}</td>
                      </tr>
                    `).join('')}
                  </tbody>
                </table>
              `;
            // End of Profitability Chart ========================================
          }
          window.profitabilityCalculation = profitabilityCalculation;

          // console.log('Swing HighLow:', swingHighLowHistory);
          // console.log('FVG History:', fvgHistory);

          // Deprecated - Create an OHLC data series
          /*
          const old_ohlcDataSeries = new OhlcDataSeries(wasmContext, {
            xValues: ohlcData.map((candle, index) => {
              
              onData(candle);

              let candleDateTime = candle[0]; // excepted format: "1970.01.01 00:00:00"
              let unixTime = convertMT5DateToUnix(candleDateTime); // format: 1624982400 for 2021-06-29 00:00:00

              let candleTime = candleDateTime.split(' ')[1]; // get the time from the date string (00:00:00)
              let candleDateTimeStamp = getCandleChartAxisLocationFromDate(candleDateTime); // 1624982400

              // let offsetedCandleTime = offsetCandleDateTimeStamp(candleDateTimeStamp); // Not really important for now, has we aren't offsetting anything yet.
              let dateOptionForSelect = candleDateTimeStamp;
              let backTestTime = getCandleChartAxisLocationFromDate(candleDateTime); // + 3600; // Actually the same as above (candleDateTimeStamp)

              var selectedTime = document.getElementById('backtesting-hour').value;

              if (candleTime == selectedTime) {
                numbDays = numbDays + 1;
                let btt = backTestTime; // * 1000;
                let formatedDate = formatDateFromUnix(btt);

                // Display Backtesting dates on the select element:
                document
                  .getElementById('NavigateTroughtDates')
                  .innerHTML += `<option value="${unixTime}">
                    ${candleDateTime}</option>`;

                // Backtesting line annotation:
                sciChartSurface.annotations.add(
                  new VerticalLineAnnotation({
                    stroke: '#999',
                    axisLabelFill: '#999',
                    strokeThickness: 1,
                    x1: unixTime,
                    showLabel: true,
                    labelPlacement: ELabelPlacement.TopLeft,
                    labelValue: `${candleDateTime}`,
                  })
                );
              }

              //onCandleDrawn(candle, index);

              // Add annotations for MSS:
              /*
                const indicateCandle = (candle, ohlcData, index) => {
                  const analysisRange = 1;
                  const currentCandleLocation = offsetedCandleTime(getCandleChartAxisLocationFromDate(candle.time));
                  const currentCandleLocationOffseted = offsetedCandleTime(getCandleChartAxisLocationFromDate(candle.time)) - 3600 * analysisRange;

                  if (index - analysisRange >= analysisRange && index - analysisRange < ohlcData.length && ohlcData[index - analysisRange] !== undefined) {
                    const x1 = currentCandleLocationOffseted;
                    const y1 = ohlcData[index - analysisRange].close;
                    const midCandleIndex = index - analysisRange;
                    const farLeftIndex = index - analysisRange - analysisRange;

                    isAfterPriceLower = ohlcData[index].high < ohlcData[midCandleIndex].high
                    isBeforePriceLower = ohlcData[farLeftIndex].high < ohlcData[midCandleIndex].high
                    if (isAfterPriceLower && isBeforePriceLower) {
                      const middleCandle = ohlcData[midCandleIndex];
                      //debugger
                      const middleCandleLocation = offsetedCandleTime(getCandleChartAxisLocationFromDate(middleCandle.time));
                      //console.log(x, a);
                      sciChartSurface.annotations.add(
                        new CustomAnnotation({
                          x1,
                          y1,
                          verticalAnchorPoint: EVerticalAnchorPoint.Top,
                          horizontalAnchorPoint: EHorizontalAnchorPoint.Center,
                          svgString:
                            '<svg id="Capa_1" xmlns="http://www.w3.org/2000/svg"><g transform="translate(-53.867218,-5.091687)"><path style="fill:#1cb61c;fill-opacity:0.34117647;stroke:#00b400;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1" d="m 55.47431,83.481251 c 7.158904,-7.408333 7.158904,-7.408333 7.158904,-7.408333 l 7.158906,7.408333 H 66.212668 V 94.593756 H 59.053761 V 83.481251 Z"/></g></svg>',
                        })
                      );
                    }
                  }
                };

                indicateCandle(candle, ohlcData, index);
              

              return unixTime; // - 3600 * 2; // broker time offset compensation (2 hours)
            }),
            openValues: ohlcData.map((candle) => candle.open),
            highValues: ohlcData.map((candle) => candle.high),
            lowValues: ohlcData.map((candle) => candle.low),
            closeValues: ohlcData.map((candle) => candle.close),
          });
          */

          const ohlcDataSeries = new OhlcDataSeries(wasmContext);

          // Create an OHLC series
          const FCRS = new FastCandlestickRenderableSeries(wasmContext, {
            dataSeries: ohlcDataSeries,
            strokeThickness: 1,
            /*
              effect: new GlowEffect(wasmContext, {
                range: 10,
                intensity: 1,
                color: "#666666",
                offset: new Point(0, 0),
              }),
              effect: new ShadowEffect(wasmContext, {
                range: 10,
                brightness: 100,
                color: '#ffffff',
                offset: new Point(10, 10)
              })
            */
          })
          sciChartSurface.renderableSeries.add(FCRS);
          
          const addNewCandleToChart = (ohlcDataRow, dataIndex) => {
            if (candlesFromBuffer.length >= MAX_BUFFER_SIZE) {
              candlesFromBuffer.shift(); // Remove the oldest element if the buffer is full to save memory
            }
            candlesFromBuffer.push(ohlcDataRow);

            onCandleDrawn(ohlcDataRow, dataIndex, candlesFromBuffer);

            ohlcDataSeries.append(
              convertMT5DateToUnix(ohlcDataRow[0]),
              ohlcDataRow[1],
              ohlcDataRow[2],
              ohlcDataRow[3],
              ohlcDataRow[4]
            );
          };
          window.addNewCandleToChart = addNewCandleToChart;

          const clearAndDeleteChart = () => {
            // Clear the select element:
            $navigateTroughtDates.innerHTML = "";

            if (ohlcDataSeries) {
              ohlcDataSeries.clear();
              sciChartSurface.annotations.clear();
            }
          };
          window.clearAndDeleteChart = clearAndDeleteChart;

          /*
          // MSS Graph Related Annotations: ========================================
            // Plot the rolling highest high and lowest low lines
            const rollingHighestHighLine = new FastLineRenderableSeries(wasmContext, {
              dataSeries: rollingHighestHighDataSeries,
              stroke: "#333333", // Orange for rolling highest high
              strokeThickness: 1,
            });
            const rollingLowestLowLine = new FastLineRenderableSeries(wasmContext, {
              dataSeries: rollingLowestLowDataSeries,
              stroke: "#333333", // Blue for rolling lowest low
              strokeThickness: 1,
            });

            sciChartSurface.renderableSeries.add(rollingHighestHighLine);
            sciChartSurface.renderableSeries.add(rollingLowestLowLine);
          // End of MSS Graph Related Annotations ========================================
          */

          // Add CursorModifier for crosshair
          sciChartSurface.chartModifiers.add(
            new CursorModifier({
              // Optional properties to configure what parts are shown
              showTooltip: false,
              showAxisLabels: true,
              showXLine: true,
              showYLine: true,
              // How close to a datapoint to show the tooltip? 10 = 10 pixels. 0 means always
              // hitTestRadius: 10,
              // Optional properties to configure the axis labels
              axisLabelFill: '#555',
              axisLabelStroke: '#ccc',
              // Optional properties to configure line and tooltip style
              crosshairStroke: '#555',
              crosshairStrokeThickness: 1,
              tooltipContainerBackground: '#000',
              // tooltipTextStroke: "#ff6600",
            })
          );

          sciChartSurface.chartModifiers.add(
            new MouseWheelZoomModifier(),
            new ZoomPanModifier(),
            new ZoomExtentsModifier(),
            new YAxisDragModifier({ dragMode: EDragMode.Scaling }),
            new XAxisDragModifier({ dragMode: EDragMode.Scaling })
          );

          // Navigate Trought Dates: ========================================
            $navigateTroughtDates.addEventListener('change', function (event) {
                const getCandleNumberByDay = (days) => 86400 * days; // Get the number of candles in a day (candle count for a entire day)
                const selectedDate = event.target.value;
                const rangeMinDate = parseInt(selectedDate) - 1800 // + half an hour
                const rangeMaxDate = parseInt(selectedDate) + getCandleNumberByDay(0.1); // getCandleChartAxisLocationFromDate(selectedDate) + getCandleNumberByDay(0.1); // half of a day
                const xAxis = sciChartSurface.xAxes.get(0);
                const yAxis = sciChartSurface.yAxes.get(0);

                // Graph Zooming:
                xAxis.visibleRange = new NumberRange(
                  rangeMinDate,
                  rangeMaxDate
                );

                // yAxis.visibleRange = new NumberRange(1, 3);
                // updateYAxisRange();
                // sciChartSurface.zoomExtents();
              });
          // End of Navigate Trought Dates ========================================

          // Tools: ========================================
            const refreshAnnotations = () => {
              annotations.forEach((annotation) => {
                console.log(annotation);
                /*document.getElementById('annotations').value = annotations
                  .map((a) => JSON.stringify(a))
                  .join('\n');*/
              });
            };
            const RRToolBoxAnnotation = (
              xGraphValue,
              yGraphValue,
              options,
            ) =>
              new BoxAnnotation({
                ...RRToolStyles,
                x1: xGraphValue - 50,
                x2: xGraphValue + 300,
                y1: yGraphValue,
                ...options,
              });

            const addRRAnnotationBox = (ed) => {
              if (ed === EnumDirection.BULL) {
                sciChartSurface.annotations.add(
                  RRToolBoxAnnotation(
                    coords.xGraphValue,
                    coords.yGraphValue,
                    {
                      fill: `#${bullishColor}${RRToolStyles.opacity}`,
                      y2: coords.yGraphValue + tpSize(),
                    },
                  )
                )
                sciChartSurface.annotations.add(
                  RRToolBoxAnnotation(
                    coords.xGraphValue,
                    coords.yGraphValue,
                    {
                      fill: `#${bearishColor}${RRToolStyles.opacity}`,
                      y2: coords.yGraphValue - slSize(),
                    },
                  )
                )
              } else {
                sciChartSurface.annotations.add(
                  RRToolBoxAnnotation(
                    coords.xGraphValue,
                    coords.yGraphValue,
                    {
                      fill: `#${bullishColor}${RRToolStyles.opacity}`,
                      y2: coords.yGraphValue - tpSize(),
                    },
                  )
                )
                sciChartSurface.annotations.add(
                  RRToolBoxAnnotation(
                    coords.xGraphValue,
                    coords.yGraphValue,
                    {
                      fill: `#${bearishColor}${RRToolStyles.opacity}`,
                      y2: coords.yGraphValue + slSize(),
                    },
                  )
                )
              };
            };

            let coords = null;
            let selectedTool = null;
            let clickCount = 0;

            let lineToolFirstPoint = null;
            let lineToolSecondPoint = null;
            let rectangleToolFirstPoint = null;
            let rectangleToolSecondPoint = null;

            sciChartSurface
              .domCanvas2D
              .addEventListener(
                'click',
                (event) => {
                  const rect = sciChartSurface.domCanvas2D.getBoundingClientRect();
                  const mouseX = event.clientX - rect.left - 10 - 73; // -10 from left offset 'border/padding' of the canvas -73 because of the points legend/markers
                  const mouseY = event.clientY - rect.top - 10; // -10 from top offset 'border/padding' of the canvas
                  const xCoordCalc = sciChartSurface.xAxes.get(0).getCurrentCoordinateCalculator();
                  const yCoordCalc = sciChartSurface.yAxes.get(0).getCurrentCoordinateCalculator();

                  coords = {
                    xPosition: xCoordCalc.getDataValue(event.clientX),
                    yPosition: yCoordCalc.getDataValue(event.clientY),
                    xGraphValue: parseFloat(xCoordCalc.getDataValue(mouseX).toFixed(0)),
                    yGraphValue: parseFloat(yCoordCalc.getDataValue(mouseY).toFixed(decimals)),
                    x: xCoordCalc,
                    y: yCoordCalc,
                  };

                  // console.log(coords);

                  /*if (isListeningForToolActions) {
                    addRRAnnotationBox(EnumDirection.BULL);
                    isListeningForToolActions = false;
                  }*/

                  if (selectedTool != null) {
                    clickCount++;
                  } else {
                    clickCount = 0;
                  }

                  // console.log(clickCount);

                  const lineToolActions = [
                    () => {
                      lineToolFirstPoint = coords;
                    },
                    () => {
                      lineToolSecondPoint = coords;
                      sciChartSurface.annotations.add(
                        new LineAnnotation({
                          stroke: `#${bullishColor}`,
                          strokeThickness: 1,
                          x1: lineToolFirstPoint.xGraphValue,
                          x2: lineToolSecondPoint.xGraphValue,
                          y1: lineToolFirstPoint.yGraphValue,
                          y2: lineToolSecondPoint.yGraphValue,
                        })
                      );
                      clickCount = 0;
                      selectedTool = null;
                    },
                  ]

                  const BOSActions = [
                    () => {
                      lineToolFirstPoint = coords;
                    },
                    () => {
                      lineToolSecondPoint = {
                        ...coords,
                        yGraphValue: lineToolFirstPoint.yGraphValue, 
                      };
                      sciChartSurface.annotations.add(
                        new LineAnnotation({
                          stroke: `#${bullishColor}`,
                          strokeThickness: 1,
                          x1: lineToolFirstPoint.xGraphValue,
                          x2: lineToolSecondPoint.xGraphValue,
                          y1: lineToolFirstPoint.yGraphValue,
                          y2: lineToolSecondPoint.yGraphValue,
                        })
                      );
                      clickCount = 0;
                      selectedTool = null;
                    },
                  ]

                  const CircleActions = [
                    () => {
                      lineToolFirstPoint = coords;
                      sciChartSurface.annotations.add(
                        new CustomAnnotation({
                          x1: lineToolFirstPoint.xGraphValue,
                          y1: lineToolFirstPoint.yGraphValue,
                          verticalAnchorPoint: EVerticalAnchorPoint.Center,
                          horizontalAnchorPoint: EHorizontalAnchorPoint.Center,
                          svgString: '<svg id="Capa_1" xmlns="http://www.w3.org/2000/svg">' +
                                    `<circle cx="10" cy="10" r="8" style="fill:#${bullishColor};fill-opacity:0.34117647;stroke:#${bullishColor};stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1" />` +
                                    '</svg>',
  
                        })
                      );
                      clickCount = 0;
                      selectedTool = null;
                    },
                    /*() => {
                      lineToolSecondPoint = {
                        ...coords,
                        yGraphValue: lineToolFirstPoint.yGraphValue, 
                      };
                    },*/
                  ]

                  const rectangleToolActions = [
                    () => {
                      rectangleToolFirstPoint = coords;
                    },
                    () => {
                      rectangleToolSecondPoint = coords;
                      sciChartSurface.annotations.add(
                        new BoxAnnotation({
                          x1: rectangleToolFirstPoint.xGraphValue,
                          x2: rectangleToolSecondPoint.xGraphValue,
                          y1: rectangleToolFirstPoint.yGraphValue,
                          y2: rectangleToolSecondPoint.yGraphValue,
                          fill: `#${bullishColor}${RRToolStyles.opacity}`,
                          stroke: `#${bullishColor}`,
                          strokeThickness: 1,
                          opacity: 0.5,
                        })
                      );
                      clickCount = 0;
                      selectedTool = null;
                    },
                  ]

                  switch (selectedTool) {
                    case 'RRBuy':
                      addRRAnnotationBox(EnumDirection.BULL);
                      clickCount = 0;
                      selectedTool = null;
                      break;
                    case 'RRSell':
                      addRRAnnotationBox(EnumDirection.SELL);
                      clickCount = 0;
                      selectedTool = null;
                      break;
                    case 'line':
                      stepByStep(clickCount, lineToolActions);
                      break;
                    case 'BOS':
                      stepByStep(clickCount, BOSActions);
                      break;
                    case 'Circle':
                      stepByStep(clickCount, CircleActions);
                      break;
                    case 'rectangle':
                      stepByStep(clickCount, rectangleToolActions);
                      break;
                    default: return;
                  }
                },
              );

            document.querySelectorAll('[data-anotation]').forEach((button) => {
              button.removeAttribute('disabled');
              button.addEventListener('click', function () {
                let isListeningForToolActions = true;
                var anotationType = this.dataset.anotation;
                const rect = sciChartSurface.domCanvas2D.getBoundingClientRect();

                const rrTool = (enumDirection) => {
                  isListeningForToolActions = true;
                };

                switch (anotationType) {
                  case 'RRBuy':
                    selectedTool = 'RRBuy';
                    break;
                  case 'RRSell':
                    selectedTool = 'RRSell';
                    break;
                  case 'line':
                    selectedTool = 'line';
                    break;
                  case 'BOS':
                    selectedTool = 'BOS';
                    break;
                  case 'Circle':
                    selectedTool = 'Circle';
                    break;
                  case 'rectangle':
                    selectedTool = 'rectangle';
                    break;
                  default:
                    console.log('No type');
                }
              });
            });
          // End of Tools ========================================
        })
        .catch((error) => {
          console.error('Error initializing SciChart:', error);
        });
    }

    const appendDataToChart = (d, dataIndex) => {
      //$csvDataField.value += JSON.stringify(d);
      addNewCandleToChart([
        `${d["<DATE>"]} ${d["<TIME>"]}`,
        d["<OPEN>"],
        d["<HIGH>"],
        d["<LOW>"],
        d["<CLOSE>"],
      ], dataIndex);
    }
  </script>
</body>

</html>