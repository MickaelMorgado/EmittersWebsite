<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" href="../assets/css.css" />
  <link rel="stylesheet" href="../assets/reusables.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css" />
  <link rel="icon" href="https://ui-avatars.com/api/?name=H&rounded=true&background=000000&color=ffffff" type="image/png">
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="../assets/reusables.js"></script>
  <script>document.addEventListener('DOMContentLoaded', function() { document.title = `HYTEK - ${document.getElementsByTagName("h1")[0].innerText}` });</script>
  <style>
    :root {
      --main-width: 350px;
      --padding: 15px;
    }

    html,
    body {
      margin: 0;
      padding: 0;
    }

    #upload-section {
      position: fixed;
      height: 100%;
      z-index: 2;
      background: rgba(0, 0, 0, 0.5);
      width: var(--main-width);
      overflow: hidden;
      transition: all 0.5s ease;
      overflow-y: auto;
    }

    #upload-section>.h-flex {
      gap: 10px;
    }

    #upload-section>.h-flex>div {
      transition: all 0.5s ease;
    }

    .chart-section {
      position: relative;
      display: flex;
      flex-direction: column;
      height: 100vh;
      margin-left: var(--main-width);
    }

    #scichart-root {
      flex-grow: 1;
    }

    .result-panel {
      position: relative;
      height: 60px;
      background: black;
      color: white;
      overflow-y: auto;
      z-index: 1;
      transition: all .5s ease;
    }

    .result-panel-toolbar {
      position: fixed;
      display: flex;
      left: var(--main-width);
      right: 0;
      gap: var(--padding);
      padding: 10px;
      background: var(--dark);
      box-shadow: 0 10px 20px -5px var(--dark3);
      box-sizing: border-box;
    }

    .result-panel-content {
      padding: 20px;
      padding-top: 90px;
    }

    .result-panel-toolbar-toggler {
      span:first-child { display: inline; }
      span:last-child { display: none; }
    }

    /* When the result panel is active: */
    .result-panel.active {
      height: 400px;
    }

    .active .result-panel-toolbar-toggler {
      span:first-child { display: none; }
      span:last-child { display: inline; }
    }

    #hidder {
      display: none;
      left: 800px;
      right: 69px;
      top: 0;
      bottom: 24px;
      background: #141515;
      z-index: 1;
      position: absolute;
    }

    .tools,
    .rules {
      position: fixed;
      top: var(--padding);
      right: var(--padding);
      background-color: var(--transparent-dark3);
      padding: calc(var(--padding) / 2);
      border-radius: 5px;
      z-index: 2;
    }

    .rules {
      top: auto;
      bottom: 40px;
    }

    .spacer {
      flex-grow: 1;
    }

    .accordion {
      width: 100%;
      border: 1px solid var(--dark3);
      border-radius: var(--radius);
      overflow: hidden;
    }

    .accordion-item {
      border-bottom: 1px solid var(--dark3);
    }

    .accordion-header {
      background-color: var(--dark);
      cursor: pointer;
    }

    .accordion-button {
      background-color: var(--dark2);
      border: none;
      font-size: 16px;
      text-align: left;
      width: 100%;
      padding: 10px;
      cursor: pointer;
      color: var(--grey1);
      text-transform: uppercase;
      font-weight: bold;
    }

    .accordion-button:focus {
      outline: none;
    }

    .accordion-collapse {
      height: 0;
      overflow: hidden;
      transition: height 0.3s ease;
    }

    .accordion-collapse.show {
      height: auto;
    }

    .accordion-body {
      padding: var(--padding);
      background-color: var(--dark);
      display: flex;
      flex-direction: column;
      gap: var(--padding);
    }

    #chatGPTFloatingIconButtonForModal {
      background: var(--dark);
      color: var(--grey1);
      border: none;
      position: absolute;
      box-shadow: 0 0 60px 5px grey;
      border: 10px solid black;
      bottom: 20px;
      right: 20px;
      width: 50px;
      height: 50px;
      padding: 10px;
      border-radius: 100%;
      cursor: pointer;
      background-image: url('../assets/images/icons/chatGPT.png');
      background-size: 100%;
      background-repeat: no-repeat;
    }
  </style>
</head>

<body class="h-style">
  <div id="upload-section">
    <div class="h-padded">
      <div class="h-flex h-flex--column">
        <div>
          <h1>BackTesting</h1>
          <p>
            Export MT5 bars by using CTRL+U then go to Bars tab, filter the
            range and export, then upload it here:
          </p>
          <p>
            More info:
            <a target="_blank" href="https://myforex.com/en/mt5guide/export-historicaldata.html">Export Historical
              Data</a>
            <a target="_blank" href="https://www.mql5.com/en/forum/356227">Limited History Issue</a>
          </p>
        </div>
        <hr class="h-hr" />
        <label for="">Upload CSV bars</label>
        <div class="h-flex">
          <input type="file" id="csvFileInput" accept=".csv" class="h-input-effects" style="width: 80%"/>
          <button id="csvRefresh" title="Refresh" class="mybutton h-input-effects">
            <i class="fas fa-repeat"></i>
          </button>
        </div>
        <hr class="h-hr" />
        <div class="h-flex">
          <div class="h-form-group">
            <label for="prevDate">Prev</label>
            <button id="prevDate" title="Previous Date" class="mybutton h-input-effects" onclick="changeDate(-1)">
              <i class="fas fa-arrow-left"></i>
            </button>
          </div>
          <div class="h-form-group">
            <label for="NavigateTroughtDates">Navigate trought dates</label>
            <select id="NavigateTroughtDates" class="h-input-effects"></select>
          </div>
          <div class="h-form-group">
            <label for="nextDate">Next</label>
            <button id="nextDate" title="Next Date" class="mybutton h-input-effects" onclick="changeDate(1)">
              <i class="fas fa-arrow-right"></i>
            </button>
          </div>
        </div>
        <script>
          function changeDate(direction) {
            const select = document.getElementById('NavigateTroughtDates');
            let newIndex = select.selectedIndex + direction;
            // Ensure newIndex is within the bounds of the select options
            if (newIndex >= 0 && newIndex < select.options.length) {
              select.selectedIndex = newIndex;
              select.dispatchEvent(new Event('change'));
            }
          }
        </script>
        <!--hr class="h-hr" />
        <label for="">Hidder</label>
        <div class="h-flex">
          <button id="hidderReset" title="Restart" class="mybutton h-input-effects" onclick="hidderRestart()">
            <i class="fas fa-repeat"></i>
          </button>
          <button id="hidderNextCandle" title="Reveal Next Candle" class="mybutton h-input-effects"
            onclick="hidderNext()">
            <i class="fas fa-arrow-right"></i>
          </button>
        </div>
        <script>
          document.addEventListener('DOMContentLoaded', () => {
            const hidder = document.getElementById('hidder');
            const moveButton = document.getElementById('hidderNextCandle');
            let intervalId;

            function moveElement() {
              if (!hidder.style.left) {
                hidder.style.left = '800px';
              }
              hidder.style.left = parseInt(hidder.style.left, 10) + 10 + 'px';
            }

            moveButton.addEventListener('mousedown', () => {
              intervalId = setInterval(moveElement, 50);
            });

            moveButton.addEventListener('mouseup', () => {
              clearInterval(intervalId);
            });

            moveButton.addEventListener('mouseleave', () => {
              clearInterval(intervalId);
            });
          });

          function hidderRestart() {
            let hidder = document.getElementById('hidder');
            if (hidder.style.display === 'none') {
              hidder.style.display = 'block';
            } else {
              hidder.style.display = 'none';
            }
            hidder.style.left = "800px";
          }
        </script-->
        <hr class="h-hr" />
        <label for="colorSettingsTutorial">Customize the chart colors theme</label>
        <div>
            <select id="themeSelector" class="h-input-effects" onchange="applyTheme()">
              <option value="">-</option>
              <option value="?bullishColor=00FF00&bearishColor=FF0000">Green / Red</option>
              <option value="?bullishColor=0000FF&bearishColor=FF00FF">Blue / Magenta</option>
              <option value="?bullishColor=FFFF00&bearishColor=00FFFF">Yellow / Cyan</option>
              <option value="?bullishColor=00cdff&bearishColor=555555">Light Blue / Grey</option>
              <option value="?bullishColor=FF5500&bearishColor=444444">Volcanic</option>
            </select>

            <script>
            function applyTheme() {
              const themeSelector = document.getElementById('themeSelector');
              const selectedTheme = themeSelector.value;
              const currentUrl = window.location.href.split('?')[0];
              window.location.href = currentUrl + selectedTheme;
            }
            </script>
        </div>
        <hr class="h-hr" />
        <label for="backtesting-hour">CSV Data</label>
        <div>
          <textarea id="csvContent" rows="10" style="width: 100%"></textarea>
        </div>
      </div>
    </div>
  </div>
  <div class="tools">
    <button class="mybutton h-input-effects" data-anotation="RRBuy" title="RR Tool (Buy)" disabled>
      <i class="fas fa-ruler-combined"></i>
    </button>
    <button class="mybutton h-input-effects" data-anotation="RRSell" title="RR Tool (Sell)" disabled>
      <i class="fas fa-ruler-combined"></i>
    </button>
    <button class="mybutton h-input-effects" data-anotation="line" title="Line Tool" disabled>
      <i class="fas fa-grip-lines"></i>
    </button>
    <button class="mybutton h-input-effects" data-anotation="BOS" title="BOS Tool" disabled>
      <i class="fas fa-grip-lines"></i>
    </button>
    <button class="mybutton h-input-effects" data-anotation="Circle" title="Circle Tool" disabled>
      <i class="fas fa-circle"></i>
    </button>
    <button class="mybutton h-input-effects" data-anotation="rectangle" title="Rectangle Tool" disabled>
      <i class="fa-regular fa-square"></i>
    </button>
  </div>
  <div id="hidder"></div>
  <div class="chart-section">
    <div id="scichart-root"></div>
    <div id="result-panel" class="result-panel">
      <div class="result-panel-toolbar">
        <button id="result-panel-toolbar-content-toggler-algo-editor" class="mybutton h-input-effects result-panel-toolbar-toggler">
          Algo Editor
        </button>
        <button id="result-panel-toolbar-content-toggler-algo" class="mybutton h-input-effects result-panel-toolbar-toggler">
          Backtesting results (Algo)
        </button>
        <button disabled id="result-panel-toolbar-content-toggler-manual" class="mybutton h-input-effects result-panel-toolbar-toggler">
          Backtesting results (Manual)
        </button>
        <div class="spacer"></div>
        <button id="result-panel-toolbar-toggler" class="mybutton h-input-effects result-panel-toolbar-toggler">
          <span><i class="fas fa-arrow-up"></i></span>
          <span><i class="fas fa-arrow-down"></i></span>
        </button>
      </div>
      <div class="result-panel-content h-flex h-flex--column">
        <h5 for="backtesting-hour">Backtesting Result (Algo)</h5>
        <div class="h-flex h-flex--row">
          <div class="h-flex h-flex--column">
            <div class="h-flex h-flex--column">
              <label for="backtesting-hour">Prefered Backtesting Hour</label>
              <input id="backtesting-hour" class="h-input-effects" type="text" value="08:00:00" />
            </div>
            <div class="h-flex h-flex--column">
              <label for="LotSize">Lot Size</label>
              <input id="LotSize" type="number" value="1.0" class="h-input-effects" />
              <label for="">RR (SL Points | TP Points)</label>
              <input id="SLPoints" type="number" value="0.0001" class="h-input-effects" />
              <input id="TPPoints" type="number" value="0.0003" class="h-input-effects" />
            </div>
          </div>
          <textarea id="backtestingResult" rows="10" style="flex-grow: 1; min-width: 20%" class="h-field"></textarea>
          <div id="myChartContainer" styles="width: 800px; height: 300px;">
            <canvas id="myChart" width="800px" height="300px"></canvas>
          </div>
        </div>
        <div>
          <div id="backtestingResultOrderHistory" class="h-field"></div>
        </div>
      </div>
      <div class="result-panel-content h-hide h-flex h-flex--column">
        <h3>Algo editor</h3>
        <div>
          The code field (textarea) below is completely customisable and runs on each candles draw, <br/>
          you can use multiple already made functions/variables and set debuggers in strategic spots. <br/>
          Your code below must require the following structure: <br/>
          <pre>
            <code>
// Some variables you can use:
let arrayOfSignals = [false, false]; // Represents 2 signals

... // Your code here

EnumActionType
  .VERTICAL_LINE
  .DRAW_A_CIRCLE
  .TAKE_A_TRADE
            </code>
          </pre>
        </div>
        <div class="h-flex">
          <textarea name="signal-condition" id="algoEditorTextareaMain0" width="100%" rows="3" style="width: 100%; white-space: nowrap;">
// Represents 2 signals:
arrayOfSignals.push(false);
arrayOfSignals.push(false);
          </textarea>
        </div>
        <div class="h-flex">
          <textarea name="signal-condition-1-code" id="algoEditorTextareaMain1" width="100%" rows="10" style="width: 100%; white-space: nowrap;">
const currentTime = hourMinutes();

// Check if the current time is within the trading window
if (currentTime >= '08:10' && currentTime <= '08:45') {
  arrayOfSignals[0] = true;
  
  // Ensure SignalSwingHighLow runs and updates the swingHighLowHistory
  if (SignalSwingHighLow()) {
    const swingHistory = swingHighLowHistory.slice(-2); // Get the last two swings
    
    if (swingHistory.length === 2) {
      const [firstSwing, secondSwing] = swingHistory;
      let tradeDirection = EnumDirection.BULL;

      if (
        (firstSwing.type === 'LOW' && secondSwing.type === 'LOW' && firstSwing.maxReachedPrice < secondSwing.maxReachedPrice) ||
        (firstSwing.type === 'HIGH' && secondSwing.type === 'HIGH' && firstSwing.maxReachedPrice > secondSwing.maxReachedPrice)
      ) {
        if (firstSwing.maxReachedPrice < secondSwing.maxReachedPrice) {
          tradeDirection = EnumDirection.BULL;
        }
        else if (firstSwing.maxReachedPrice > secondSwing.maxReachedPrice) {
          tradeDirection = EnumDirection.BEAR;
        }
        arrayOfSignals[0] = true; // Mark swing point detection signal as valid
        // Limit to one trade per trading window
        if (!arrayOfSignals[1]) {
          arrayOfSignals[1] = true;
          AddActionOnChart(
            EnumActionType.TAKE_A_TRADE,
            tradeDirection,
          );
        }
      } else {
        arrayOfSignals[0] = false; // Reset signal if conditions are not met
      }
    }
  }
  
  // Add an additional time-based signal for the end of the trading window
  if (currentTime === '08:10') {
    AddActionOnChart(EnumActionType.VERTICAL_LINE);
  }
  if (currentTime === '08:45') {
    AddActionOnChart(EnumActionType.VERTICAL_LINE);
  }
} else {
  // Reset signals outside the time range
  arrayOfSignals[0] = false;
  arrayOfSignals[1] = false;
}
          </textarea>
        </div>
        <div>
          <hr class="h-hr">
        </div>
        <div class="h-flex" style="position: relative;">
          <pre><code data="chatGPT-container"></code></pre>
          <textarea width="100%" rows="5" style="width: 100%; white-space: nowrap;" name="promptAI" id="promptAI" placeholder="ASK AI to build a strategy and click on button ->"></textarea>
          <button id="chatGPTFloatingIconButtonForModal"></button>
          <script>
            document.getElementById('chatGPTFloatingIconButtonForModal').addEventListener('click', () => {
              const providedCode = document.getElementById('algoEditorTextareaMain1').value;
              const userInput = document.getElementById('promptAI').value;
              const prompt = `
                ${providedCode}

                The code I provided to you runs on each new candle drawn on chart, and the code will be user inserted (via textarea) to make different trading strategies.

                Some variables and functions already created / defined so no need to redefine them:
                arrayOfSignals is simply an array of boolean that represents a trading plan validation
                EnumActionType will be mostly used with AddActionOnChart(EnumActionType), it has the following values: VERTICAL_LINE, DRAW_A_CIRCLE, TAKE_A_TRADE.
                AddActionOnChart will run function to add anotations on chart or event actions like taking a trade (annotations and other logics for the app backtesting system I already made)
                hourMinutes() will return a string based on the current candle.time (candle is always available on each candle drawn)
                SignalSwingHighLow() this function detect a swing and add data on swingHighLowHistory object, here is the example of its object structure: {time: string, maxReachedPrice: number, type: string}
                SignalConditionFVG() this function detect fvgs and add data on fvgHistory object, here is the example of its object structure: {id: index, time: string, initialPrice: number, gapFinalPrice: number, middlePrice: number, direction: string, tested: boolean}

                Using some of my functions and variables I already created make a strategy based on the following (just show me the code):

                ${userInput}
              `;
              chatGPTRequest(prompt);
            });
          </script>
        </div>
        <!--div class="accordion">
          <div class="accordion-item">
            <div class="accordion-header" id="headingOne">
              <button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapseOne" aria-expanded="true" aria-controls="collapseOne">
                Signal Condition 1
              </button>
            </div>
            <div id="collapseOne" class="accordion-collapse collapse" aria-labelledby="headingOne" data-bs-parent="#accordionExample">
              <div class="accordion-body">
                <label for="signal-condition-1-code">Make sure to return a boolean value (that's what makes the signal to take trade), You can set a debugger / pause execution near SignalCondition2() function to see how it works and debug all variables:</label>
                <textarea name="signal-condition-1-code" id="algoEditorTextarea" width="100%" rows="10">hourMinutes() == '08:10';</textarea>
                <label for="signal-condition-1-annotation">Signal Display Type (Signal representation on chart after valid condition from above returned code):</label>
                <select name="signal-condition-1-annotation" id="signalCondition1Annotation">
                  <option value="vertical-line">Vertical Line</option>
                  <option value="draw-a-circle">Draw a circle</option>
                  <option value="take-a-trade">Take a Trade</option>
                </select>
              </div>
            </div>
          </div>
          <div class="accordion-item">
            <div class="accordion-header" id="headingTwo">
              <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseTwo" aria-expanded="false" aria-controls="collapseTwo">
                Signal Condition 2
              </button>
            </div>
            <div id="collapseTwo" class="accordion-collapse collapse" aria-labelledby="headingTwo" data-bs-parent="#accordionExample">
              <div class="accordion-body">
                <label for="signal-condition-2-code">Make sure to return a boolean value (that's what makes the signal to take trade), You can set a debugger / pause execution near SignalCondition2() function to see how it works and debug all variables:</label>
                <textarea name="signal-condition-2-code" id="algoEditorTextarea2" width="100%" rows="10">hourMinutes() == '08:45' && hourMinutes() >= '08:10'; // TODO: replace 'true' buy previous returned result</textarea>
                <label for="signal-condition-2-annotation">Signal Display Type (Signal representation on chart after valid condition from above returned code):</label>
                <select name="signal-condition-2-annotation" id="signalCondition2Annotation">
                  <option value="vertical-line">Vertical Line</option>
                  <option value="draw-a-circle">Draw a circle</option>
                  <option value="take-a-trade">Take a Trade</option>
                </select>
              </div>
            </div>
          </div>
          <div class="accordion-item">
            <div class="accordion-header" id="headingThree">
              <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseThree" aria-expanded="false" aria-controls="collapseThree">
                Signal Condition 3
              </button>
            </div>
            <div id="collapseThree" class="accordion-collapse collapse" aria-labelledby="headingThree" data-bs-parent="#accordionExample">
              <div class="accordion-body">
                <label for="signal-condition-3-code">Make sure to return a boolean value (that's what makes the signal to take trade), You can set a debugger / pause execution near SignalCondition2() function to see how it works and debug all variables:</label>
                <textarea name="signal-condition-3-code" id="algoEditorTextarea3" width="100%" rows="10">hourMinutes() == '08:45' && SignalCondition2(); // TODO: replace 'true' buy previous returned result</textarea>
                <label for="signal-condition-3-annotation">Signal Display Type (Signal representation on chart after valid condition from above returned code):</label>
                <select name="signal-condition-3-annotation" id="signalCondition3Annotation">
                  <option value="vertical-line">Vertical Line</option>
                  <option value="draw-a-circle">Draw a circle</option>
                  <option value="take-a-trade">Take a Trade</option>
                </select>
              </div>
            </div>
          </div>
        </div>
        <script>
          document.querySelectorAll('.accordion-button').forEach(button => {
            button.addEventListener('click', () => {
              const accordionItem = button.closest('.accordion-item');
              const collapseElement = accordionItem.querySelector('.accordion-collapse');

              if (collapseElement.classList.contains('show')) {
                collapseElement.style.height = `${collapseElement.scrollHeight}px`;
                setTimeout(() => {
                  collapseElement.style.height = '0';
                }, 0);
                collapseElement.classList.remove('show');
              } else {
                document.querySelectorAll('.accordion-collapse.show').forEach(openItem => {
                  openItem.style.height = '0';
                  openItem.classList.remove('show');
                });
                collapseElement.classList.add('show');
                collapseElement.style.height = `${collapseElement.scrollHeight}px`;
              }
            });
          });
        </script-->
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/scichart/index.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
  <script>
    // Result Panel Related Actions / Triggers:
    const resultPanel = document.querySelector('#result-panel');
    const csvRefresh = document.querySelector('#csvRefresh');
    const toolbarToggler = document.querySelector('#result-panel-toolbar-toggler');
    function toggleHeight() {
      resultPanel.classList.toggle('active');
    }
    toolbarToggler.addEventListener('click', toggleHeight);

    document.getElementById('result-panel-toolbar-content-toggler-algo').addEventListener('click', () => {
      resultPanel.classList.add('active');
      document.querySelectorAll('.result-panel-content')[0].classList.remove('h-hide');
      document.querySelectorAll('.result-panel-content')[1].classList.add('h-hide');
    });

    document.getElementById('result-panel-toolbar-content-toggler-algo-editor').addEventListener('click', () => {
      resultPanel.classList.add('active');
      document.querySelectorAll('.result-panel-content')[0].classList.add('h-hide');
      document.querySelectorAll('.result-panel-content')[1].classList.remove('h-hide');
    });

    csvRefresh.addEventListener('click', () => {
      const file = document.getElementById('csvFileInput').files[0];
      if (file) {
        const reader = new FileReader();
        reader.readAsText(file);
        reader.onload = function (e) {
          const content = e.target.result;

          document.getElementById('csvContent').value = content;

          initSciChart(content);
        }
        document.getElementById('result-panel-toolbar-content-toggler-algo').click();
      }
    });

    /* ---- */

    const decimals = 5;
    let slSize = () => parseFloat(document.getElementById('SLPoints').value);
    let tpSize = () => parseFloat(document.getElementById('TPPoints').value);
    let lotSize = () => parseFloat(document.getElementById('LotSize').value);
    const EnumDirection = {
      BULL: 'BULL',
      BEAR: 'BEAR',
    };
    const EnumOrderStatus = {
      PENDING: 'PENDING',
      CLOSED_BY_TP: 'CLOSED_BY_TP',
      CLOSED_BY_SL: 'CLOSED_BY_SL',
    };
    const EnumActionType = {
      VERTICAL_LINE: 'VERTICAL_LINE',
      DRAW_A_CIRCLE: 'DRAW_A_CIRCLE',
      TAKE_A_TRADE: 'TAKE_A_TRADE',
    };

    const getCandleDirection = (candle) => {
      return candle.close > candle.open ? EnumDirection.BULL : EnumDirection.BEAR;
    };

    const getCandleChartAxisLocationFromDate = (date) => {
      return new Date(date).getTime() / 1000;
    };

    // Window assignments:
    window.getCandleChartAxisLocationFromDate = getCandleChartAxisLocationFromDate;

    function formatDateFromUnix(unixTime) {
      const options = {
        year: 'numeric',
        month: 'numeric',
        day: 'numeric',
        hour: '2-digit',
        minute: '2-digit',
        // second: '2-digit',
        hour12: false,
      };
      return new Date(unixTime * 1000).toLocaleDateString('en-GB', options); // Multiply by 1000 to convert to milliseconds because JS Date works with milliseconds.
    }

    // Handy function to execute actions step by step:
    const stepByStep = (step, actions) => {
      return actions[step - 1]();
    };

    const convertMT5DateToUnix = (candleTime) => {
      const ct = candleTime.replaceAll('.','-');
      return new Date(ct).getTime() / 1000; // divided by 1000 to convert from milliseconds to seconds as Unix time only accepts seconds, while JS Date is more precise as working with milliseconds.
    };

    document
      .getElementById('csvFileInput')
      .addEventListener('change', function loadcsv (event) {
        const file = event.target.files[0];
        if (file) {
          const reader = new FileReader();
          reader.onload = function (e) {
            const content = e.target.result;

            document.getElementById('csvContent').value = content;

            initSciChart(content);
            document.getElementById('scichart-root').style.display = 'block';
          };
          reader.readAsText(file);
          // Here we need to update select dates with the new data:
          // buildChartData();

          // Expand Backtesting panel:
          document.getElementById('result-panel-toolbar-content-toggler-algo').click();
        } else {
          // alert('No file selected');
        }
      });

    // Define the initSciChart function
    function initSciChart(data) {
      const {
        SciChartSurface,
        NumericAxis,
        FastCandlestickRenderableSeries,
        OhlcDataSeries,
        SciChartJsNavyTheme,
        SciChartJSDarkv2Theme,
        NumberRange,
        MouseWheelZoomModifier,
        ZoomPanModifier,
        ZoomExtentsModifier,
        YAxisDragModifier,
        XAxisDragModifier,
        DateTimeNumericAxis,
        DateLabelProvider,
        EDragMode,
        CursorModifier,
        BoxAnnotation,
        ECoordinateMode,
        getCanvasCoordinatesFromEvent,
        VerticalLineAnnotation,
        SolidColorBrush,
        Colors,
        ELabelPlacement,
        EAnnotationLayer,
        DateRange,
        EAutoRange,
        LineAnnotation,
        AxisMarkerAnnotation,
        CustomAnnotation,
        EVerticalAnchorPoint,
        EHorizontalAnchorPoint,
        ENumericFormat,
        EDateFormatter,
        Point,
        // GlowEffect,
        // ShadowEffect,
      } = SciChart;

      // Tell SciChart where to get webassembly files from.
      SciChartSurface.useWasmFromCDN();

      // Initialize SciChartSurface. Don't forget to await!
      SciChartSurface.create('scichart-root', {
        theme: new SciChartJsNavyTheme(),
      })
        .then(({ sciChartSurface, wasmContext }) => {

          let bullishColor = '00FF00';
          let bearishColor = 'FF0000';
          let greyColor = '999999';

          // Extract URL parameters
          const urlParams = new URLSearchParams(window.location.search);
          bullishColor = decodeURIComponent(urlParams.get('bullishColor') || bullishColor);
          bearishColor = decodeURIComponent(urlParams.get('bearishColor') || bearishColor);
          
          // Create a custom theme by implementing all the properties from IThemeProvider
          const customTheme = {
            axisBorder: 'Transparent',
            axisTitleColor: '#111',
            annotationsGripsBackroundBrush: 'white',
            annotationsGripsBorderBrush: 'white',
            axis3DBandsFill: '#1F3D6833',
            axisBandsFill: '#1F3D6833',
            axisPlaneBackgroundFill: 'Transparent',
            columnFillBrush: 'white',
            columnLineColor: 'Transparent',
            cursorLineBrush: '#111',
            downBandSeriesFillColor: '#52CC5490',
            downBandSeriesLineColor: '#E26565FF',
            downBodyBrush: bearishColor, // candle
            downWickColor: bearishColor, // candle
            gridBackgroundBrush: 'white',
            gridBorderBrush: 'white',
            labelForegroundBrush: '#EEEEEE',
            legendBackgroundBrush: '#1D2C35',
            lineSeriesColor: 'white',
            loadingAnimationBackground: '#111',
            loadingAnimationForeground: '#111',
            majorGridLineBrush: '#111',
            minorGridLineBrush: '#111',
            mountainAreaBrush: 'white',
            mountainLineColor: 'white',
            overviewFillBrush: 'white',
            planeBorderColor: 'white',
            rolloverLineBrush: '#FD9F2533',
            rubberBandFillBrush: '#99999933',
            rubberBandStrokeBrush: '#99999977',
            sciChartBackground: '#000', // Chart background color
            scrollbarBackgroundBrush: 'white',
            scrollbarBorderBrush: 'white',
            scrollbarGripsBackgroundBrush: 'white',
            scrollbarViewportBackgroundBrush: 'white',
            scrollbarViewportBorderBrush: 'white',
            shadowEffectColor: 'white',
            textAnnotationBackground: '#333',
            textAnnotationForeground: '#EEEEEE',
            tickTextBrush: '#333',
            upBandSeriesFillColor: 'white',
            upBandSeriesLineColor: 'white',
            upBodyBrush: bullishColor, // candle
            upWickColor: bullishColor, // candle
          };

          // customTheme = new SciChartJsNavyTheme();

          sciChartSurface.applyTheme(customTheme);

          window.sciChartSurface = sciChartSurface;

          // Create an XAxis and YAxis with growBy padding
          // sciChartSurface.xAxes.add(new NumericAxis(wasmContext, { axisTitle: "Time", growBy }));
          // sciChartSurface.yAxes.add(new NumericAxis(wasmContext, { axisTitle: "Price", growBy }));

          const signalAnnotation = {
            svgString: {
              buy: '<svg id="Capa_1" xmlns="http://www.w3.org/2000/svg" width="10" height="10" viewBox="0 0 10 10"><g transform="translate(-54.616083,-75.548914)"><path style="fill:#0000FF;" d="M 55,85 L 60,75 L 65,85 Z"/></g></svg>',
              bullish: '<svg id="Capa_1" xmlns="http://www.w3.org/2000/svg" width="10" height="10" viewBox="0 0 10 10"><g transform="translate(-54.616083,-75.548914)"><path style="fill:#00FF00;" d="M 55,85 L 60,75 L 65,85 Z"/></g></svg>',
              sell: '<svg id="Capa_1" xmlns="http://www.w3.org/2000/svg" width="10" height="10" viewBox="0 0 10 10"><g transform="translate(-54.616083,-75.548914)"><path style="fill:#FF0000;" d="M 55,75 L 60,85 L 65,75 Z"/></g></svg>',
              bearish: '<svg id="Capa_1" xmlns="http://www.w3.org/2000/svg" width="10" height="10" viewBox="0 0 10 10"><g transform="translate(-54.616083,-75.548914)"><path style="fill:#FF0000;" d="M 55,75 L 60,85 L 65,75 Z"/></g></svg>',
              circle: `<svg id="Capa_1" xmlns="http://www.w3.org/2000/svg"><circle cx="10" cy="10" r="8" style="fill:#${bullishColor};fill-opacity:0.34117647;stroke:#${bullishColor};stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1" /></svg>`,
            },
          };

          const RRToolStyles = {
            strokeThickness: 0,
            xCoordinateMode: ECoordinateMode.DataValue,
            yCoordinateMode: ECoordinateMode.DataValue,
            annotationLayer: EAnnotationLayer.AboveChart,
            opacity: '50',
          };

          function ceilToDecimalPlaces(num, decimalPlaces) {
            const factor = Math.pow(10, decimalPlaces); // Calculate 10^decimalPlaces
            return Math.ceil(num * factor) / factor; // Ceil and then divide
          }

          const buildChartData = (data) => {
            let numbDays = 0;
            const growBy = new NumberRange(0.1, 0.1);
            // Extract OHLC data from the response

            // Parse CSV content
            const rows = data.trim().split('\r\n'); // Split by lines
            const header = rows[0].split('\t'); // Extract headers
            const rdata = rows.slice(1).map((row) => row.split('\t')); // Split rows into fields

            const ohlcData = rdata.map((row) => {
              /*https://developers.binance.com/docs/binance-spot-api-docs/rest-api#klinecandlestick-data*/
              /*
                return {
                  time: row[0],
                  open: parseFloat(row[1]),
                  high: parseFloat(row[2]),
                  low: parseFloat(row[3]),
                  close: parseFloat(row[4])
                }
              */

              /* MT5 exported CSV format: */
              return {
                time: `${row[0]} ${row[1]}`,
                open: parseFloat(row[2]),
                high: parseFloat(row[3]),
                low: parseFloat(row[4]),
                close: parseFloat(row[5]),
              };
            });

            let ordersHistory = [];
            let swingHighLowHistory = [];
            let fvgHistory = [];
            const minDate = new Date(ohlcData[0].time);
            const maxDate = new Date(ohlcData[ohlcData.length - 1].time);
            const offsetCandleDateTimeStamp = (candleDateTimeStamp) => candleDateTimeStamp; // - 3600 * 1; // !! offseting candle position in X axis by -1h to match tradingView (The correct way would be to offset the axis labels, but dont know how to do it yet)

            // First function to be executed as soon as the data is loaded, you can do anything you want here:
            const onData = (ohlcData) => {
              // console.log('ohlcData:', ohlcData);
            }
            // Second function to be executed after the candle is drawn, you can add annotations here:
            const onCandleDrawn = (candle, index) => {
              const candlePosition = convertMT5DateToUnix(candle.time);
              const prevCandle = ohlcData[index - 1];
              const nextCandle = ohlcData[index + 1];

              // Check for tp/sl hit:
              ordersHistory.forEach((order) => {
                switch (order.direction) {
                  case EnumDirection.BULL:
                    if (candle.high >= order.tp && !order.closed) {

                      order.closed = true;
                      order.closedPrice = order.tp;
                      order.closedTime = candle.time;
                      order.orderStatus = EnumOrderStatus.CLOSED_BY_TP,

                      sciChartSurface.annotations.add(
                        new CustomAnnotation({
                          x1: convertMT5DateToUnix(order.closedTime),
                          y1: order.tp,
                          verticalAnchorPoint: EVerticalAnchorPoint.Center,
                          horizontalAnchorPoint: EHorizontalAnchorPoint.Center,
                          svgString: signalAnnotation.svgString.sell,
                        })
                      );
                      sciChartSurface.annotations.add(
                        new LineAnnotation({
                          stroke: `#${greyColor}`,
                          strokeThickness: 1,
                          strokeDashArray: [5, 5],
                          x1: convertMT5DateToUnix(order.time),
                          x2: convertMT5DateToUnix(order.closedTime),
                          y1: order.price,
                          y2: order.closedPrice,
                        })
                      );
                    }
                    if (candle.low <= order.sl && !order.closed) {

                      order.closed = true;
                      order.closedPrice = order.sl;
                      order.closedTime = candle.time;
                      order.orderStatus = EnumOrderStatus.CLOSED_BY_SL,

                      sciChartSurface.annotations.add(
                        new CustomAnnotation({
                          x1: convertMT5DateToUnix(order.closedTime),
                          y1: order.sl,
                          verticalAnchorPoint: EVerticalAnchorPoint.Center,
                          horizontalAnchorPoint: EHorizontalAnchorPoint.Center,
                          svgString: signalAnnotation.svgString.sell,
                        })
                      );
                      sciChartSurface.annotations.add(
                        new LineAnnotation({
                          stroke: `#${greyColor}`,
                          strokeThickness: 1,
                          strokeDashArray: [5, 5],
                          x1: convertMT5DateToUnix(order.time),
                          x2: convertMT5DateToUnix(order.closedTime),
                          y1: order.price,
                          y2: order.closedPrice,
                        })
                      );
                    }
                    break;
                  case EnumDirection.BEAR:
                    if (candle.low <= order.tp && !order.closed) {

                      order.closed = true;
                      order.closedPrice = order.tp;
                      order.closedTime = candle.time;
                      order.orderStatus = EnumOrderStatus.CLOSED_BY_TP,

                      sciChartSurface.annotations.add(
                        new CustomAnnotation({
                          x1: convertMT5DateToUnix(order.closedTime),
                          y1: order.tp,
                          verticalAnchorPoint: EVerticalAnchorPoint.Center,
                          horizontalAnchorPoint: EHorizontalAnchorPoint.Center,
                          svgString: signalAnnotation.svgString.sell,
                        })
                      );
                      sciChartSurface.annotations.add(
                        new LineAnnotation({
                          stroke: `#${greyColor}`,
                          strokeThickness: 1,
                          strokeDashArray: [5, 5],
                          x1: convertMT5DateToUnix(order.time),
                          x2: convertMT5DateToUnix(order.closedTime),
                          y1: order.price,
                          y2: order.closedPrice,
                        })
                      );
                    }
                    if (candle.high >= order.sl && !order.closed) {

                      order.closed = true;
                      order.closedPrice = order.sl;
                      order.closedTime = candle.time;
                      order.orderStatus = EnumOrderStatus.CLOSED_BY_SL,

                      sciChartSurface.annotations.add(
                        new CustomAnnotation({
                          x1: convertMT5DateToUnix(order.closedTime),
                          y1: order.sl,
                          verticalAnchorPoint: EVerticalAnchorPoint.Center,
                          horizontalAnchorPoint: EHorizontalAnchorPoint.Center,
                          svgString: signalAnnotation.svgString.sell,
                        })
                      );
                      sciChartSurface.annotations.add(
                        new LineAnnotation({
                          stroke: `#${greyColor}`,
                          strokeThickness: 1,
                          strokeDashArray: [5, 5],
                          x1: convertMT5DateToUnix(order.time),
                          x2: convertMT5DateToUnix(order.closedTime),
                          y1: order.price,
                          y2: order.closedPrice,
                        })
                      );
                    }
                    break;
                }
              });

              // Check for FVG tested:
              fvgHistory.forEach((fvg) => {
                if (fvg.tested) return;
                // Check if wick candle is within the FVG range (currently too much perfectionism here it might reduce the quantity of signals):
                const testBullishFVG = candle.low > fvg.initialPrice && candle.low < fvg.gapFinalPrice;
                const testBearishFVG = candle.high < fvg.initialPrice && candle.high > fvg.gapFinalPrice;
                if ((testBullishFVG || testBearishFVG) && !fvg.tested) { // At this point we confirmly tested the FVG
                  fvg.tested = true;
                  // console.log('FVG / Candle', fvg, candle);
                }
              });

              // A FVG signal:
              const fvgExtent = 8;
              let isBullishFVG = false;
              let isBearishFVG = false;

              const SignalConditionFVG = () => {
                if (index < 3 || index > ohlcData.length - (fvgExtent + 1)) return false;
                isBullishFVG = nextCandle.low > prevCandle.high;
                isBearishFVG = prevCandle.low > nextCandle.high;

                return isBullishFVG || isBearishFVG;
              };

              if (SignalConditionFVG()) {
                const initialPrice = isBullishFVG ? prevCandle.high : prevCandle.low;
                const gapFinalPrice = isBullishFVG ? nextCandle.low : nextCandle.high;
                const differencial = Math.abs(nextCandle.low - prevCandle.high) / 2;

                // Calculate the middle price and round it to 5 decimal places
                const middlePrice = ceilToDecimalPlaces(initialPrice + differencial, 5);

                fvgHistory.push({
                  id: index,
                  time: candle.time,
                  initialPrice: initialPrice,
                  gapFinalPrice: gapFinalPrice,
                  middlePrice: middlePrice,
                  direction: getCandleDirection(candle) == 'BULL' ? EnumDirection.BULL : EnumDirection.BEAR,
                  tested: false,
                });

                sciChartSurface.annotations.add(
                  new BoxAnnotation({
                    x1: convertMT5DateToUnix(prevCandle.time),
                    x2: convertMT5DateToUnix(ohlcData[index + fvgExtent].time),
                    y1: getCandleDirection(candle) == 'BULL' ? prevCandle.high : prevCandle.low,
                    y2: getCandleDirection(candle) == 'BULL' ? nextCandle.low : nextCandle.high,
                    fill: `#${getCandleDirection(candle) == 'BULL' ? bullishColor : bearishColor}${RRToolStyles.opacity}`,
                    stroke: `#${getCandleDirection(candle) == 'BULL' ? bullishColor : bearishColor}`,
                    strokeThickness: 1,
                    opacity: 0.3,
                  })
                );
              }

              // Function to create annotations or take actions on the chart, based on UI selected options:
              const AddActionOnChart = (EnumActionType, tradeDirection = EnumDirection.BULL) => {
                  switch (EnumActionType) {
                  case 'VERTICAL_LINE':
                    sciChartSurface.annotations.add(
                      new VerticalLineAnnotation({
                        x1: candlePosition,
                        stroke: `#${bullishColor}`,
                        strokeThickness: 1,
                      })
                    );
                    break;
                  case 'DRAW_A_CIRCLE':
                    sciChartSurface.annotations.add(
                      new CustomAnnotation({
                        x1: candlePosition,
                        y1: candle.close,
                        verticalAnchorPoint: EVerticalAnchorPoint.Center,
                        horizontalAnchorPoint: EHorizontalAnchorPoint.Center,
                        svgString: signalAnnotation.svgString.circle,
                      })
                    );
                    break;
                  case 'TAKE_A_TRADE':
                    const orderOptionsBasedDirection = (tradeDirection) => {
                      if (tradeDirection == EnumDirection.BULL) {
                        return {
                          sl: candle.close - slSize(),
                          tp: candle.close + tpSize(),
                          direction: EnumDirection.BULL,
                        };
                      } else {
                        return {
                          sl: candle.close + slSize(),
                          tp: candle.close - tpSize(),
                          direction: EnumDirection.BEAR,
                        };
                      }
                    };
                    // Add order to history:
                    ordersHistory.push({
                      id: index,
                      time: candle.time,
                      price: candle.close,
                      orderStatus: EnumOrderStatus.PENDING,
                      ...orderOptionsBasedDirection(tradeDirection),
                    });

                    // Add annotation from entry:
                    sciChartSurface.annotations.add(
                      new CustomAnnotation({
                        x1: candlePosition,
                        y1: candle.close,
                        verticalAnchorPoint: EVerticalAnchorPoint.Center,
                        horizontalAnchorPoint: EHorizontalAnchorPoint.Center,
                        svgString: signalAnnotation.svgString.buy,
                      })
                    );
                    break;
                }
              }

              /* Global variables and functions */
              const algoEditorTextareaMain0 = document.getElementById('algoEditorTextareaMain0');
              const algoEditorTextareaMain1 = document.getElementById('algoEditorTextareaMain1');
              const hourMinutes = () => candle.time.split(' ')[1].slice(0, 5);
              let arrayOfSignals = [];
              eval(algoEditorTextareaMain0.value);

              /*
                const SignalCondition1 = () => {
                  const algoEditorTextarea = document.getElementById('algoEditorTextarea');
                  return eval(algoEditorTextarea.value);
                }

                if (SignalCondition1()) {
                  AddActionOnChart('signalCondition1Annotation');
                }

                const SignalCondition2 = () => {
                  const algoEditorTextarea = document.getElementById('algoEditorTextarea2');
                  return eval(algoEditorTextarea.value);
                }

                if (SignalCondition2()) {
                  AddActionOnChart('signalCondition2Annotation');
                }

                const SignalCondition3 = () => {
                  const algoEditorTextarea = document.getElementById('algoEditorTextarea3');
                  return eval(algoEditorTextarea.value);
                }

                if (SignalCondition3()) {
                  AddActionOnChart('signalCondition3Annotation');
                }
              */

              let isSwingHigh = false;
              let isSwingLow = false;

              const SignalSwingHighLow = () => {
                if (index < 4 || index > ohlcData.length - 3) return false;
                const prevCandle = ohlcData[index - 1];
                const prevCandle2 = ohlcData[index - 2];
                const nextCandle = ohlcData[index + 1];
                const nextCandle2 = ohlcData[index + 2];
                isSwingHigh = prevCandle.high <= candle.high && nextCandle.high <= candle.high && nextCandle2.high <= nextCandle.high && prevCandle.high <= candle.high && getCandleDirection(candle) == 'BEAR'; // && getCandleDirection(prevCandle) == 'BULL' && getCandleDirection(nextCandle) == 'BEAR'; // red
                isSwingLow = prevCandle.low >= candle.low && nextCandle.low >= candle.low && nextCandle2.low >= nextCandle.low && prevCandle.low >= candle.low && getCandleDirection(candle) == 'BULL'; // && getCandleDirection(prevCandle) == 'BEAR' && getCandleDirection(nextCandle) == 'BULL'; // green

                return isSwingLow || isSwingHigh;
              }

              if (SignalSwingHighLow()) {
                swingHighLowHistory.push({
                  time: candle.time,
                  maxReachedPrice: isSwingHigh ? candle.high : candle.low, // Represents the highest/lowest price that was reached.
                  type: isSwingHigh ? 'HIGH' : 'LOW', // Represents the type of the swing (HIGH or LOW) its the position and NOT the candle direction.
                });

                sciChartSurface.annotations.add(
                  new CustomAnnotation({
                    x1: candlePosition,
                    y1: isSwingHigh ? candle.high : candle.low,
                    verticalAnchorPoint: EVerticalAnchorPoint.Center,
                    horizontalAnchorPoint: EHorizontalAnchorPoint.Center,
                    svgString: isSwingHigh ? signalAnnotation.svgString.bearish : signalAnnotation.svgString.bullish,
                  })
                );
              }

              eval(algoEditorTextareaMain1.value);

              if (index == ohlcData.length - 1) {
                
                const profitsInPoints = ordersHistory.reduce((acc, order) => {
                  if (order.orderStatus == EnumOrderStatus.CLOSED_BY_TP) {
                    return acc + tpSize();
                  }
                  if (order.orderStatus == EnumOrderStatus.CLOSED_BY_SL) {
                    return acc - slSize();
                  }
                  return acc;
                }, 0);

                console.log('Orders History:', ordersHistory);
                const winRate = ordersHistory.length > 0 ? (ordersHistory.filter((order) => order.orderStatus == EnumOrderStatus.CLOSED_BY_TP).length / ordersHistory.length * 100).toFixed(2) : 0;
                const moneyEquivalent = ((profitsInPoints * (lotSize() * 10)) * 10000).toFixed(2);
                const result = `Check console for orders history\n\nTrade Taken: ${ordersHistory.length} (in ${numbDays} days)\nWin Rate: ${winRate}% \n\nProfits: \n Money: ${moneyEquivalent}$\n Points: ${profitsInPoints.toFixed(5)} \n Pips: ${(profitsInPoints / 0.00010).toFixed(2)} \n Ticks: ${(profitsInPoints / 0.01).toFixed(2)}`;
                //const result = `Check console for orders history\n\nTrade Taken: ${ordersHistory.length}\nWin Rate: ${winRate}% \n\nProfits: \n Money: ${moneyEquivalent}$\n Points: ${profitsInPoints} \n Pips: ${(profitsInPoints / 0.00010)}`;
                document.getElementById('backtestingResult').value = result;
     
                // Create a line chart:
                let myChart = document.getElementById('myChart');
                var ctx = myChart.getContext('2d');
                var datasets = [];
                var values = ordersHistory.map((order) => {
                  const pnlvar = order.orderStatus == EnumOrderStatus.CLOSED_BY_TP ? tpSize() : -slSize();
                  return [pnlvar];
                });
                
                console.log('creating equity chart')

                const pnlsum = () => {
                  let sum = 0;
                  return values.map((value) => {
                    var a = (sum += parseFloat(value));
                    return a;
                  });
                };

                // Check if there is an existing chart instance and destroy it:
                if (typeof myChart !== 'undefined' && myChart !== null) {
                  myChart.remove();
                  const newCanvas = document.createElement('canvas');
                  newCanvas.id = 'myChart';
                  newCanvas.width = 800;
                  newCanvas.height = 300;
                  document.getElementById('myChartContainer').appendChild(newCanvas);
                  myChart = document.getElementById('myChart');
                  ctx = myChart.getContext('2d');
                  //myChart.destroy();
                }

                gradient = ctx.createLinearGradient(0, 25, 0, 300);
                gradient.addColorStop(0, `#${bullishColor}${RRToolStyles.opacity}`);
                gradient.addColorStop(1, `#${bearishColor}${RRToolStyles.opacity}`);

                datasets.push({
                  type: 'line',
                  label: 'Equity',
                  data: pnlsum(),
                  //backgroundColor: `#${bullishColor}`,
                  borderColor: `#${bullishColor}`,
                  backgroundColor: gradient,
                  borderWidth: 1,
                  order: 0,
                  fill: true,
                });
                
                // Create profitability chart:
                var options = {
                  //animation,
                  responsive: false,
                  elements: {
                    point: {
                      radius: 1,
                    },
                  },
                  scales: {
                    y: {
                      beginAtZero: false,
                    },
                    /*
                      scales: {
                          myScale: {
                          type: 'logarithmic',
                          position: 'right',
                          },
                      },
                    */
                  },
                };

                // Set maximum and minimum values for y-axis if provided
                /*if (minValue) {
                  options.scales.y.min = minValue;
                }
                if (maxValue) {
                  options.scales.y.max = maxValue;
                }*/

                myChart = new Chart(ctx, {
                  type: 'line',
                  data: {
                    labels: values,	
                    datasets: datasets,
                  },
                  options: options,
                });
                
                document.getElementById('backtestingResultOrderHistory').innerHTML = `
                  <table>
                    <thead>
                      <tr>
                        <th>ID</th>
                        <th>Time</th>
                        <th>Price</th>
                        <th>SL</th>
                        <th>TP</th>
                        <th>Direction</th>
                        <th>Order Status</th>
                        <th>Closed Price</th>
                        <th>Closed Time</th>
                      </tr>
                    </thead>
                    <tbody>
                      ${ordersHistory.map(order => `
                        <tr>
                          <td>${order.id}</td>
                          <td>${order.time}</td>
                          <td>${order.price.toFixed(5)}</td>
                          <td>${order.sl.toFixed(5)}</td>
                          <td>${order.tp.toFixed(5)}</td>
                          <td>${order.direction}</td>
                          <td>${order.orderStatus}</td>
                          <td>${order.closedPrice || ''}</td>
                          <td>${order.closedTime || ''}</td>
                        </tr>
                      `).join('')}
                    </tbody>
                  </table>
                `;
              }
            }

            console.log('Swing HighLow:', swingHighLowHistory);
            console.log('FVG History:', fvgHistory);

            // Clear the select element:
            document
              .getElementById('NavigateTroughtDates')
              .innerHTML = "";

            // Create an OHLC data series
            const ohlcDataSeries = new OhlcDataSeries(wasmContext, {
              xValues: ohlcData.map((candle, index) => {
                
                onData(candle);

                let candleDateTime = candle.time; // excepted format: "1970.01.01 00:00:00"
                let unixTime = convertMT5DateToUnix(candleDateTime); // format: 1624982400 for 2021-06-29 00:00:00

                let candleTime = candleDateTime.split(' ')[1]; // get the time from the date string (00:00:00)
                let candleDateTimeStamp = getCandleChartAxisLocationFromDate(candleDateTime); // 1624982400

                let offsetedCandleTime = offsetCandleDateTimeStamp(candleDateTimeStamp); // Not really important for now, has we aren't offsetting anything yet.
                let dateOptionForSelect = candleDateTimeStamp;
                let backTestTime = getCandleChartAxisLocationFromDate(candleDateTime); // + 3600; // Actually the same as above (candleDateTimeStamp)

                var selectedTime = document.getElementById('backtesting-hour').value;

                if (candleTime == selectedTime) {
                  numbDays = numbDays + 1;
                  let btt = backTestTime; // * 1000;
                  let formatedDate = formatDateFromUnix(btt);

                  // Display Backtesting dates on the select element:
                  document
                    .getElementById('NavigateTroughtDates')
                    .innerHTML += `<option value="${unixTime}">
                      ${candleDateTime}</option>`;

                  // Backtesting line annotation:
                  sciChartSurface.annotations.add(
                    new VerticalLineAnnotation({
                      stroke: '#999',
                      axisLabelFill: '#999',
                      strokeThickness: 1,
                      x1: unixTime,
                      showLabel: true,
                      labelPlacement: ELabelPlacement.TopLeft,
                      labelValue: `${candleDateTime}`,
                    })
                  );
                }

                onCandleDrawn(candle, index);

                // Add annotations for MSS:
                /*
                  const indicateCandle = (candle, ohlcData, index) => {
                    const analysisRange = 1;
                    const currentCandleLocation = offsetedCandleTime(getCandleChartAxisLocationFromDate(candle.time));
                    const currentCandleLocationOffseted = offsetedCandleTime(getCandleChartAxisLocationFromDate(candle.time)) - 3600 * analysisRange;

                    if (index - analysisRange >= analysisRange && index - analysisRange < ohlcData.length && ohlcData[index - analysisRange] !== undefined) {
                      const x1 = currentCandleLocationOffseted;
                      const y1 = ohlcData[index - analysisRange].close;
                      const midCandleIndex = index - analysisRange;
                      const farLeftIndex = index - analysisRange - analysisRange;

                      isAfterPriceLower = ohlcData[index].high < ohlcData[midCandleIndex].high
                      isBeforePriceLower = ohlcData[farLeftIndex].high < ohlcData[midCandleIndex].high
                      if (isAfterPriceLower && isBeforePriceLower) {
                        const middleCandle = ohlcData[midCandleIndex];
                        //debugger
                        const middleCandleLocation = offsetedCandleTime(getCandleChartAxisLocationFromDate(middleCandle.time));
                        //console.log(x, a);
                        sciChartSurface.annotations.add(
                          new CustomAnnotation({
                            x1,
                            y1,
                            verticalAnchorPoint: EVerticalAnchorPoint.Top,
                            horizontalAnchorPoint: EHorizontalAnchorPoint.Center,
                            svgString:
                              '<svg id="Capa_1" xmlns="http://www.w3.org/2000/svg"><g transform="translate(-53.867218,-5.091687)"><path style="fill:#1cb61c;fill-opacity:0.34117647;stroke:#00b400;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1" d="m 55.47431,83.481251 c 7.158904,-7.408333 7.158904,-7.408333 7.158904,-7.408333 l 7.158906,7.408333 H 66.212668 V 94.593756 H 59.053761 V 83.481251 Z"/></g></svg>',
                          })
                        );
                      }
                    }
                  };

                  indicateCandle(candle, ohlcData, index);
                */

                return unixTime; // + 3600;
              }),
              openValues: ohlcData.map((candle) => candle.open),
              highValues: ohlcData.map((candle) => candle.high),
              lowValues: ohlcData.map((candle) => candle.low),
              closeValues: ohlcData.map((candle) => candle.close),
            });

            const xAxis = new DateTimeNumericAxis(wasmContext, { growBy });
            // Cursor labels:
            xAxis.labelProvider.formatCursorLabel = (dataValue) => {
              const unixDateStamp = Math.floor(dataValue); // Flooring it to remove milliseconds from that cursor data, as it is too much precise // - 3600;
              return formatDateFromUnix(unixDateStamp);
            };
            const yAxis = new NumericAxis(wasmContext, {
              labelPrecision: decimals,
              autoRange: EAutoRange.Always,
              growBy,
            });

            sciChartSurface.xAxes.add(xAxis);
            sciChartSurface.yAxes.add(yAxis);

            // Create an OHLC series
            sciChartSurface.renderableSeries.add(
              new FastCandlestickRenderableSeries(wasmContext, {
                dataSeries: ohlcDataSeries,
                strokeThickness: 1,
                /*
                  effect: new GlowEffect(wasmContext, {
                    range: 10,
                    intensity: 1,
                    color: "#666666",
                    offset: new Point(0, 0),
                  }),
                  effect: new ShadowEffect(wasmContext, {
                    range: 10,
                    brightness: 100,
                    color: '#ffffff',
                    offset: new Point(10, 10)
                  })
                */
              })
            );

            // Add CursorModifier for crosshair
            sciChartSurface.chartModifiers.add(
              new CursorModifier({
                // Optional properties to configure what parts are shown
                showTooltip: false,
                showAxisLabels: true,
                showXLine: true,
                showYLine: true,
                // How close to a datapoint to show the tooltip? 10 = 10 pixels. 0 means always
                // hitTestRadius: 10,
                // Optional properties to configure the axis labels
                axisLabelFill: '#555',
                axisLabelStroke: '#ccc',
                // Optional properties to configure line and tooltip style
                crosshairStroke: '#555',
                crosshairStrokeThickness: 1,
                tooltipContainerBackground: '#000',
                // tooltipTextStroke: "#ff6600",
              })
            );

            document
              .getElementById('NavigateTroughtDates')
              .addEventListener('change', function (event) {
                const getCandleNumberByDay = (days) => 86400 * days; // Get the number of candles in a day (candle count for a entire day)
                const selectedDate = event.target.value;
                const rangeMinDate = parseInt(selectedDate) - 1800 // + half an hour
                const rangeMaxDate = parseInt(selectedDate) + getCandleNumberByDay(0.1); // getCandleChartAxisLocationFromDate(selectedDate) + getCandleNumberByDay(0.1); // half of a day
                const xAxis = sciChartSurface.xAxes.get(0);
                const yAxis = sciChartSurface.yAxes.get(0);

                xAxis.visibleRange = new NumberRange(
                  rangeMinDate,
                  rangeMaxDate
                );
                // yAxis.visibleRange = new NumberRange(1.07, 1.084);
                // sciChartSurface.zoomExtents();
              });

            sciChartSurface.chartModifiers.add(
              new MouseWheelZoomModifier(),
              new ZoomPanModifier(),
              new ZoomExtentsModifier(),
              new YAxisDragModifier({
                dragMode: EDragMode.Scaling,
              }),
              new XAxisDragModifier({
                dragMode: EDragMode.Scaling,
              })
            );
          };

          buildChartData(data);
          // Axios code to fetch data
          /*
            axios.get('https://api.binance.com/api/v3/klines?symbol=LTCBTC&interval=1m').then(response => {
              const data = response.data;
              // buildChartData(data);
            }).catch(error => {
              console.error('Error fetching data:', error);
            });
          */

          /*
            sciChartSurface.domCanvas2D.addEventListener('click', (event) => {
              //const coords = getCanvasCoordinatesFromEvent(sciChartSurface.domCanvas2D, event);
              //console.log(coords);
            });
          */

          let annotations = [];

          const refreshAnnotations = () => {
            annotations.forEach((annotation) => {
              console.log(annotation);
              /*document.getElementById('annotations').value = annotations
                .map((a) => JSON.stringify(a))
                .join('\n');*/
            });
          };

          const RRToolBoxAnnotation = (
            xGraphValue,
            yGraphValue,
            options,
          ) =>
            new BoxAnnotation({
              ...RRToolStyles,
              x1: xGraphValue - 50,
              x2: xGraphValue + 300,
              y1: yGraphValue,
              ...options,
            });

          const addRRAnnotationBox = (ed) => {
            if (ed === EnumDirection.BULL) {
              sciChartSurface.annotations.add(
                RRToolBoxAnnotation(
                  coords.xGraphValue,
                  coords.yGraphValue,
                  {
                    fill: `#${bullishColor}${RRToolStyles.opacity}`,
                    y2: coords.yGraphValue + tpSize(),
                  },
                )
              )
              sciChartSurface.annotations.add(
                RRToolBoxAnnotation(
                  coords.xGraphValue,
                  coords.yGraphValue,
                  {
                    fill: `#${bearishColor}${RRToolStyles.opacity}`,
                    y2: coords.yGraphValue - slSize(),
                  },
                )
              )
            } else {
              sciChartSurface.annotations.add(
                RRToolBoxAnnotation(
                  coords.xGraphValue,
                  coords.yGraphValue,
                  {
                    fill: `#${bullishColor}${RRToolStyles.opacity}`,
                    y2: coords.yGraphValue - tpSize(),
                  },
                )
              )
              sciChartSurface.annotations.add(
                RRToolBoxAnnotation(
                  coords.xGraphValue,
                  coords.yGraphValue,
                  {
                    fill: `#${bearishColor}${RRToolStyles.opacity}`,
                    y2: coords.yGraphValue + slSize(),
                  },
                )
              )
            };
          };

          // Tools:

          let coords = null;
          let selectedTool = null;
          let clickCount = 0;

          let lineToolFirstPoint = null;
          let lineToolSecondPoint = null;
          let rectangleToolFirstPoint = null;
          let rectangleToolSecondPoint = null;

          sciChartSurface
            .domCanvas2D
            .addEventListener(
              'click',
              (event) => {
                const rect = sciChartSurface.domCanvas2D.getBoundingClientRect();
                const mouseX = event.clientX - rect.left - 10 - 73; // -10 from left offset 'border/padding' of the canvas -73 because of the points legend/markers
                const mouseY = event.clientY - rect.top - 10; // -10 from top offset 'border/padding' of the canvas
                const xCoordCalc = sciChartSurface.xAxes.get(0).getCurrentCoordinateCalculator();
                const yCoordCalc = sciChartSurface.yAxes.get(0).getCurrentCoordinateCalculator();

                coords = {
                  xPosition: xCoordCalc.getDataValue(event.clientX),
                  yPosition: yCoordCalc.getDataValue(event.clientY),
                  xGraphValue: parseFloat(xCoordCalc.getDataValue(mouseX).toFixed(0)),
                  yGraphValue: parseFloat(yCoordCalc.getDataValue(mouseY).toFixed(decimals)),
                  x: xCoordCalc,
                  y: yCoordCalc,
                };

                // console.log(coords);

                /*if (isListeningForToolActions) {
                  addRRAnnotationBox(EnumDirection.BULL);
                  isListeningForToolActions = false;
                }*/

                if (selectedTool != null) {
                  clickCount++;
                } else {
                  clickCount = 0;
                }

                // console.log(clickCount);

                const lineToolActions = [
                  () => {
                    lineToolFirstPoint = coords;
                  },
                  () => {
                    lineToolSecondPoint = coords;
                    sciChartSurface.annotations.add(
                      new LineAnnotation({
                        stroke: `#${bullishColor}`,
                        strokeThickness: 1,
                        x1: lineToolFirstPoint.xGraphValue,
                        x2: lineToolSecondPoint.xGraphValue,
                        y1: lineToolFirstPoint.yGraphValue,
                        y2: lineToolSecondPoint.yGraphValue,
                      })
                    );
                    clickCount = 0;
                    selectedTool = null;
                  },
                ]

                const BOSActions = [
                  () => {
                    lineToolFirstPoint = coords;
                  },
                  () => {
                    lineToolSecondPoint = {
                      ...coords,
                      yGraphValue: lineToolFirstPoint.yGraphValue, 
                    };
                    sciChartSurface.annotations.add(
                      new LineAnnotation({
                        stroke: `#${bullishColor}`,
                        strokeThickness: 1,
                        x1: lineToolFirstPoint.xGraphValue,
                        x2: lineToolSecondPoint.xGraphValue,
                        y1: lineToolFirstPoint.yGraphValue,
                        y2: lineToolSecondPoint.yGraphValue,
                      })
                    );
                    clickCount = 0;
                    selectedTool = null;
                  },
                ]

                const CircleActions = [
                  () => {
                    lineToolFirstPoint = coords;
                    sciChartSurface.annotations.add(
                      new CustomAnnotation({
                        x1: lineToolFirstPoint.xGraphValue,
                        y1: lineToolFirstPoint.yGraphValue,
                        verticalAnchorPoint: EVerticalAnchorPoint.Center,
                        horizontalAnchorPoint: EHorizontalAnchorPoint.Center,
                        svgString: '<svg id="Capa_1" xmlns="http://www.w3.org/2000/svg">' +
                                   `<circle cx="10" cy="10" r="8" style="fill:#${bullishColor};fill-opacity:0.34117647;stroke:#${bullishColor};stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1" />` +
                                   '</svg>',
 
                      })
                    );
                    clickCount = 0;
                    selectedTool = null;
                  },
                  /*() => {
                    lineToolSecondPoint = {
                      ...coords,
                      yGraphValue: lineToolFirstPoint.yGraphValue, 
                    };
                  },*/
                ]

                const rectangleToolActions = [
                  () => {
                    rectangleToolFirstPoint = coords;
                  },
                  () => {
                    rectangleToolSecondPoint = coords;
                    sciChartSurface.annotations.add(
                      new BoxAnnotation({
                        x1: rectangleToolFirstPoint.xGraphValue,
                        x2: rectangleToolSecondPoint.xGraphValue,
                        y1: rectangleToolFirstPoint.yGraphValue,
                        y2: rectangleToolSecondPoint.yGraphValue,
                        fill: `#${bullishColor}${RRToolStyles.opacity}`,
                        stroke: `#${bullishColor}`,
                        strokeThickness: 1,
                        opacity: 0.5,
                      })
                    );
                    clickCount = 0;
                    selectedTool = null;
                  },
                ]

                switch (selectedTool) {
                  case 'RRBuy':
                    addRRAnnotationBox(EnumDirection.BULL);
                    clickCount = 0;
                    selectedTool = null;
                    break;
                  case 'RRSell':
                    addRRAnnotationBox(EnumDirection.SELL);
                    clickCount = 0;
                    selectedTool = null;
                    break;
                  case 'line':
                    stepByStep(clickCount, lineToolActions);
                    break;
                  case 'BOS':
                    stepByStep(clickCount, BOSActions);
                    break;
                  case 'Circle':
                    stepByStep(clickCount, CircleActions);
                    break;
                  case 'rectangle':
                    stepByStep(clickCount, rectangleToolActions);
                    break;
                  default: return;
                }
              },
            );

          document.querySelectorAll('[data-anotation]').forEach((button) => {
            button.removeAttribute('disabled');
            button.addEventListener('click', function () {
              let isListeningForToolActions = true;
              var anotationType = this.dataset.anotation;
              const rect = sciChartSurface.domCanvas2D.getBoundingClientRect();

              const rrTool = (enumDirection) => {
                isListeningForToolActions = true;
              };

              switch (anotationType) {
                case 'RRBuy':
                  selectedTool = 'RRBuy';
                  break;
                case 'RRSell':
                  selectedTool = 'RRSell';
                  break;
                case 'line':
                  selectedTool = 'line';
                  break;
                case 'BOS':
                  selectedTool = 'BOS';
                  break;
                case 'Circle':
                  selectedTool = 'Circle';
                  break;
                case 'rectangle':
                  selectedTool = 'rectangle';
                  break;
                default:
                  console.log('No type');
              }
            });
          });

          // Add some interaction modifiers to show zooming and panning
          // sciChartSurface.chartModifiers.add(new MouseWheelZoomModifier(), new ZoomPanModifier(), new ZoomExtentsModifier());
        })
        .catch((error) => {
          console.error('Error initializing SciChart:', error);
        });
    }

    // Add some interaction modifiers to show zooming and panning
    // sciChartSurface.chartModifiers.add(new MouseWheelZoomModifier(), new ZoomPanModifier(), new ZoomExtentsModifier());

    // Call initSciChart after the window has finished loading
    // window.onload = initSciChart;
  </script>
</body>

</html>