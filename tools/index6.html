<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" href="../assets/css.css" />
  <link rel="stylesheet" href="../assets/reusables.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css" />
  <link rel="icon" href="https://ui-avatars.com/api/?name=H&rounded=true&background=000000&color=ffffff" type="image/png">
  <script>document.addEventListener('DOMContentLoaded', function() { document.title = `HYTEK - ${document.getElementsByTagName("h1")[0].innerText}` });</script>
  <style>
    :root {
      --main-width: 350px;
      --padding: 15px;
    }

    html,
    body {
      margin: 0;
      padding: 0;
    }

    #upload-section {
      position: fixed;
      height: 100%;
      z-index: 2;
      background: rgba(0, 0, 0, 0.5);
      width: var(--main-width);
      overflow: hidden;
      transition: all 0.5s ease;
      overflow-y: auto;
    }

    #upload-section>.h-flex {
      gap: 10px;
    }

    #upload-section>.h-flex>div {
      transition: all 0.5s ease;
    }

    .chart-section {
      position: relative;
      display: flex;
      flex-direction: column;
      height: 100vh;
      margin-left: var(--main-width);
    }

    #scichart-root {
      flex-grow: 1;
    }

    .result-panel {
      position: relative;
      height: 60px;
      background: black;
      color: white;
      overflow-y: auto;
      z-index: 1;
      transition: all .5s ease;
    }

    .result-panel-toolbar {
      position: fixed;
      display: flex;
      left: var(--main-width);
      right: 0;
      gap: var(--padding);
      padding: 10px;
      background: var(--dark);
      box-shadow: 0 10px 20px -5px var(--dark3);
      box-sizing: border-box;
    }

    .result-panel-content {
      padding: 20px;
      padding-top: 90px;
    }

    .result-panel-toolbar-toggler {
      span:first-child { display: inline; }
      span:last-child { display: none; }
    }

    /* When the result panel is active: */
    .result-panel.active {
      height: 300px;
    }

    .active .result-panel-toolbar-toggler {
      span:first-child { display: none; }
      span:last-child { display: inline; }
    }

    #hidder {
      display: none;
      left: 800px;
      right: 69px;
      top: 0;
      bottom: 24px;
      background: #141515;
      z-index: 1;
      position: absolute;
    }

    .tools,
    .rules {
      position: fixed;
      top: var(--padding);
      right: var(--padding);
      background-color: var(--transparent-dark3);
      padding: calc(var(--padding) / 2);
      border-radius: 5px;
      z-index: 2;
    }

    .rules {
      top: auto;
      bottom: 40px;
    }

    .spacer {
      flex-grow: 1;
    }
  </style>
</head>

<body class="h-style">
  <div id="upload-section">
    <div class="h-padded">
      <div class="h-flex h-flex--column">
        <div>
          <h1>BackTesting</h1>
          <p>
            Export MT5 bars by using CTRL+U then go to Bars tab, filter the
            range and export, then upload it here:
          </p>
          <p>
            More info:
            <a target="_blank" href="https://myforex.com/en/mt5guide/export-historicaldata.html">Export Historical
              Data</a>
          </p>
        </div>
        <hr class="h-hr" />
        <label for="">Upload CSV bars</label>
        <input type="file" id="csvFileInput" accept=".csv" class="h-input-effects" />
        <hr class="h-hr" />
        <div class="h-flex">
          <div class="h-form-group">
            <label for="prevDate">Prev</label>
            <button id="prevDate" title="Previous Date" class="mybutton h-input-effects" onclick="changeDate(-1)">
              <i class="fas fa-arrow-left"></i>
            </button>
          </div>
          <div class="h-form-group">
            <label for="NavigateTroughtDates">Navigate trought dates</label>
            <select id="NavigateTroughtDates" class="h-input-effects"></select>
          </div>
          <div class="h-form-group">
            <label for="nextDate">Next</label>
            <button id="nextDate" title="Next Date" class="mybutton h-input-effects" onclick="changeDate(1)">
              <i class="fas fa-arrow-right"></i>
            </button>
          </div>
        </div>
        <script>
          function changeDate(direction) {
            const select = document.getElementById('NavigateTroughtDates');
            let newIndex = select.selectedIndex + direction;
            // Ensure newIndex is within the bounds of the select options
            if (newIndex >= 0 && newIndex < select.options.length) {
              select.selectedIndex = newIndex;
              select.dispatchEvent(new Event('change'));
            }
          }
        </script>
        <hr class="h-hr" />
        <label for="">Hidder</label>
        <div class="h-flex">
          <button id="hidderReset" title="Restart" class="mybutton h-input-effects" onclick="hidderRestart()">
            <i class="fas fa-repeat"></i>
          </button>
          <button id="hidderNextCandle" title="Reveal Next Candle" class="mybutton h-input-effects"
            onclick="hidderNext()">
            <i class="fas fa-arrow-right"></i>
          </button>
        </div>
        <script>
          document.addEventListener('DOMContentLoaded', () => {
            const hidder = document.getElementById('hidder');
            const moveButton = document.getElementById('hidderNextCandle');
            let intervalId;

            function moveElement() {
              if (!hidder.style.left) {
                hidder.style.left = '800px';
              }
              hidder.style.left = parseInt(hidder.style.left, 10) + 10 + 'px';
            }

            moveButton.addEventListener('mousedown', () => {
              intervalId = setInterval(moveElement, 50);
            });

            moveButton.addEventListener('mouseup', () => {
              clearInterval(intervalId);
            });

            moveButton.addEventListener('mouseleave', () => {
              clearInterval(intervalId);
            });
          });

          function hidderRestart() {
            let hidder = document.getElementById('hidder');
            if (hidder.style.display === 'none') {
              hidder.style.display = 'block';
            } else {
              hidder.style.display = 'none';
            }
            hidder.style.left = "800px";
          }
        </script>
        <hr class="h-hr" />
        <label for="backtesting-hour">CSV Data</label>
        <div>
          <textarea id="csvContent" rows="10" style="width: 100%"></textarea>
        </div>
        <hr class="h-hr" />
        <label for="colorSettingsTutorial">Customize the colors by adding the following parameters to the URL</label>
        <div>
          <textarea id="colorSettingsTutorial" style="width: 100%">?bullishColor=00FF00&bearishColor=FF0000</textarea>
        </div>
      </div>
    </div>
  </div>
  <div class="tools">
    <button class="mybutton h-input-effects" data-anotation="RRBuy" title="RR Tool (Buy)" disabled>
      <i class="fas fa-ruler-combined"></i>
    </button>
    <button class="mybutton h-input-effects" data-anotation="RRSell" title="RR Tool (Sell)" disabled>
      <i class="fas fa-ruler-combined"></i>
    </button>
    <button class="mybutton h-input-effects" data-anotation="line" title="Line Tool" disabled>
      <i class="fas fa-grip-lines"></i>
    </button>
    <button class="mybutton h-input-effects" data-anotation="BOS" title="BOS Tool" disabled>
      <i class="fas fa-grip-lines"></i>
    </button>
    <button class="mybutton h-input-effects" data-anotation="Circle" title="Circle Tool" disabled>
      <i class="fas fa-circle"></i>
    </button>
    <button class="mybutton h-input-effects" data-anotation="rectangle" title="Rectangle Tool" disabled>
      <i class="fa-regular fa-square"></i>
    </button>
  </div>
  <div id="hidder"></div>
  <div class="chart-section">
    <div id="scichart-root"></div>
    <div id="result-panel" class="result-panel">
      <div class="result-panel-toolbar">
        <button id="result-panel-toolbar-content-toggler-algo" class="mybutton h-input-effects result-panel-toolbar-toggler">
          Backtesting results (Algo)
        </button>
        <button disabled id="result-panel-toolbar-content-toggler-manual" class="mybutton h-input-effects result-panel-toolbar-toggler">
          Backtesting results (Manual)
        </button>
        <button disabled id="result-panel-toolbar-content-toggler-algo-editor" class="mybutton h-input-effects result-panel-toolbar-toggler">
          Algo Editor
        </button>
        <div class="spacer"></div>
        <button id="result-panel-toolbar-toggler" class="mybutton h-input-effects result-panel-toolbar-toggler">
          <span><i class="fas fa-arrow-up"></i></span>
          <span><i class="fas fa-arrow-down"></i></span>
        </button>
      </div>
      <div class="result-panel-content h-flex h-flex--column">
        <h5 for="backtesting-hour">Backtesting Result (Algo)</h5>
        <div class="h-flex h-flex--row">
          <div class="h-flex h-flex--column">
            <div class="h-flex h-flex--column">
              <label for="backtesting-hour">Prefered Backtesting Hour</label>
              <input id="backtesting-hour" class="h-input-effects" type="text" value="08:00:00" />
            </div>
            <div class="h-flex h-flex--column">
              <label for="LotSize">Lot Size</label>
              <input id="LotSize" type="number" value="1.0" class="h-input-effects" />
              <label for="">RR (SL Points | TP Points)</label>
              <input id="SLPoints" type="number" value="0.0001" class="h-input-effects" />
              <input id="TPPoints" type="number" value="0.0003" class="h-input-effects" />
            </div>
          </div>
          <textarea id="backtestingResult" rows="10" style="width: 100%" class="h-field"></textarea>
        </div>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/scichart/index.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
  <script>
    // Result Panel Related Actions / Triggers:
    const resultPanel = document.querySelector('#result-panel');
    const toolbarToggler = document.querySelector('#result-panel-toolbar-toggler');
    function toggleHeight() {
      resultPanel.classList.toggle('active');
    }
    toolbarToggler.addEventListener('click', toggleHeight);

    document.getElementById('result-panel-toolbar-content-toggler-algo').addEventListener('click', () => {
      resultPanel.classList.add('active');
    });

    /* ---- */

    const decimals = 5;
    let slSize = () => parseFloat(document.getElementById('SLPoints').value);
    let tpSize = () => parseFloat(document.getElementById('TPPoints').value);
    let lotSize = () => parseFloat(document.getElementById('LotSize').value);
    const EnumDirection = {
      BULL: 'BULL',
      BEAR: 'BEAR',
    };
    const EnumOrderStatus = {
      PENDING: 'PENDING',
      CLOSED_BY_TP: 'CLOSED_BY_TP',
      CLOSED_BY_SL: 'CLOSED_BY_SL',
    };

    const getCandleDirection = (candle) => {
      return candle.close > candle.open ? EnumDirection.BULL : EnumDirection.BEAR;
    };

    const getCandleChartAxisLocationFromDate = (date) => {
      return new Date(date).getTime() / 1000;
    };

    // Window assignments:
    window.getCandleChartAxisLocationFromDate = getCandleChartAxisLocationFromDate;

    function formatDateFromUnix(unixTime) {
      const options = {
        year: 'numeric',
        month: 'numeric',
        day: 'numeric',
        hour: '2-digit',
        minute: '2-digit',
        // second: '2-digit',
        hour12: false,
      };
      return new Date(unixTime * 1000).toLocaleDateString('en-GB', options); // Multiply by 1000 to convert to milliseconds because JS Date works with milliseconds.
    }

    // Handy function to execute actions step by step:
    const stepByStep = (step, actions) => {
      return actions[step - 1]();
    };

    const convertMT5DateToUnix = (candleTime) => {
      const ct = candleTime.replaceAll('.','-');
      return new Date(ct).getTime() / 1000; // divided by 1000 to convert from milliseconds to seconds as Unix time only accepts seconds, while JS Date is more precise as working with milliseconds.
    };

    document
      .getElementById('csvFileInput')
      .addEventListener('change', function (event) {
        const file = event.target.files[0];
        if (file) {
          const reader = new FileReader();
          reader.onload = function (e) {
            const content = e.target.result;

            document.getElementById('csvContent').value = content;

            initSciChart(content);
            document.getElementById('scichart-root').style.display = 'block';
          };
          reader.readAsText(file);
          // Here we need to update select dates with the new data:
          // buildChartData();

          // Expand Backtesting panel:
          document.getElementById('result-panel-toolbar-content-toggler-algo').click();
        } else {
          alert('No file selected');
        }
      });

    // Define the initSciChart function
    function initSciChart(data) {
      const {
        SciChartSurface,
        NumericAxis,
        FastCandlestickRenderableSeries,
        OhlcDataSeries,
        SciChartJsNavyTheme,
        SciChartJSDarkv2Theme,
        NumberRange,
        MouseWheelZoomModifier,
        ZoomPanModifier,
        ZoomExtentsModifier,
        YAxisDragModifier,
        XAxisDragModifier,
        DateTimeNumericAxis,
        DateLabelProvider,
        EDragMode,
        CursorModifier,
        BoxAnnotation,
        ECoordinateMode,
        getCanvasCoordinatesFromEvent,
        VerticalLineAnnotation,
        SolidColorBrush,
        Colors,
        ELabelPlacement,
        EAnnotationLayer,
        DateRange,
        EAutoRange,
        LineAnnotation,
        AxisMarkerAnnotation,
        CustomAnnotation,
        EVerticalAnchorPoint,
        EHorizontalAnchorPoint,
        ENumericFormat,
        EDateFormatter,
        Point,
      } = SciChart;

      // Tell SciChart where to get webassembly files from.
      SciChartSurface.useWasmFromCDN();

      // Initialize SciChartSurface. Don't forget to await!
      SciChartSurface.create('scichart-root', {
        theme: new SciChartJsNavyTheme(),
      })
        .then(({ sciChartSurface, wasmContext }) => {

          let bullishColor = '00FF00';
          let bearishColor = 'FF0000';
          let greyColor = '999999';

          // Extract URL parameters
          const urlParams = new URLSearchParams(window.location.search);
          bullishColor = decodeURIComponent(urlParams.get('bullishColor') || bullishColor);
          bearishColor = decodeURIComponent(urlParams.get('bearishColor') || bearishColor);
          
          // Create a custom theme by implementing all the properties from IThemeProvider
          const customTheme = {
            axisBorder: 'Transparent',
            axisTitleColor: '#111',
            annotationsGripsBackroundBrush: 'white',
            annotationsGripsBorderBrush: 'white',
            axis3DBandsFill: '#1F3D6833',
            axisBandsFill: '#1F3D6833',
            axisPlaneBackgroundFill: 'Transparent',
            columnFillBrush: 'white',
            columnLineColor: 'Transparent',
            cursorLineBrush: '#111',
            downBandSeriesFillColor: '#52CC5490',
            downBandSeriesLineColor: '#E26565FF',
            downBodyBrush: bearishColor,
            downWickColor: bearishColor,
            gridBackgroundBrush: 'white',
            gridBorderBrush: 'white',
            labelForegroundBrush: '#EEEEEE',
            legendBackgroundBrush: '#1D2C35',
            lineSeriesColor: 'white',
            loadingAnimationBackground: '#111',
            loadingAnimationForeground: '#111',
            majorGridLineBrush: '#111',
            minorGridLineBrush: '#111',
            mountainAreaBrush: 'white',
            mountainLineColor: 'white',
            overviewFillBrush: 'white',
            planeBorderColor: 'white',
            rolloverLineBrush: '#FD9F2533',
            rubberBandFillBrush: '#99999933',
            rubberBandStrokeBrush: '#99999977',
            sciChartBackground: '#000',
            scrollbarBackgroundBrush: 'white',
            scrollbarBorderBrush: 'white',
            scrollbarGripsBackgroundBrush: 'white',
            scrollbarViewportBackgroundBrush: 'white',
            scrollbarViewportBorderBrush: 'white',
            shadowEffectColor: 'white',
            textAnnotationBackground: '#333',
            textAnnotationForeground: '#EEEEEE',
            tickTextBrush: '#333',
            upBandSeriesFillColor: 'white',
            upBandSeriesLineColor: 'white',
            upBodyBrush: bullishColor,
            upWickColor: bullishColor,
          };

          // customTheme = new SciChartJsNavyTheme();

          sciChartSurface.applyTheme(customTheme);

          window.sciChartSurface = sciChartSurface;

          // Create an XAxis and YAxis with growBy padding
          // sciChartSurface.xAxes.add(new NumericAxis(wasmContext, { axisTitle: "Time", growBy }));
          // sciChartSurface.yAxes.add(new NumericAxis(wasmContext, { axisTitle: "Price", growBy }));

          const signalAnnotation = {
            svgString: {
              buy: '<svg id="Capa_1" xmlns="http://www.w3.org/2000/svg" width="10" height="10" viewBox="0 0 10 10"><g transform="translate(-54.616083,-75.548914)"><path style="fill:#0000FF;" d="M 55,85 L 60,75 L 65,85 Z"/></g></svg>',
              bullish: '<svg id="Capa_1" xmlns="http://www.w3.org/2000/svg" width="10" height="10" viewBox="0 0 10 10"><g transform="translate(-54.616083,-75.548914)"><path style="fill:#00FF00;" d="M 55,85 L 60,75 L 65,85 Z"/></g></svg>',
              sell: '<svg id="Capa_1" xmlns="http://www.w3.org/2000/svg" width="10" height="10" viewBox="0 0 10 10"><g transform="translate(-54.616083,-75.548914)"><path style="fill:#FF0000;" d="M 55,75 L 60,85 L 65,75 Z"/></g></svg>',
              bearish: '<svg id="Capa_1" xmlns="http://www.w3.org/2000/svg" width="10" height="10" viewBox="0 0 10 10"><g transform="translate(-54.616083,-75.548914)"><path style="fill:#FF0000;" d="M 55,75 L 60,85 L 65,75 Z"/></g></svg>',
            },
          };

          const buildChartData = (data) => {
            const growBy = new NumberRange(0.1, 0.1);
            // Extract OHLC data from the response

            // Parse CSV content
            const rows = data.trim().split('\r\n'); // Split by lines
            const header = rows[0].split('\t'); // Extract headers
            const rdata = rows.slice(1).map((row) => row.split('\t')); // Split rows into fields

            const ohlcData = rdata.map((row) => {
              /*https://developers.binance.com/docs/binance-spot-api-docs/rest-api#klinecandlestick-data*/
              /*
                return {
                  time: row[0],
                  open: parseFloat(row[1]),
                  high: parseFloat(row[2]),
                  low: parseFloat(row[3]),
                  close: parseFloat(row[4])
                }
              */

              /* MT5 exported CSV format: */
              return {
                time: `${row[0]} ${row[1]}`,
                open: parseFloat(row[2]),
                high: parseFloat(row[3]),
                low: parseFloat(row[4]),
                close: parseFloat(row[5]),
              };
            });

            let ordersHistory = [];
            const minDate = new Date(ohlcData[0].time);
            const maxDate = new Date(ohlcData[ohlcData.length - 1].time);
            const offsetCandleDateTimeStamp = (candleDateTimeStamp) => candleDateTimeStamp; // - 3600 * 1; // !! offseting candle position in X axis by -1h to match tradingView (The correct way would be to offset the axis labels, but dont know how to do it yet)

            // First function to be executed as soon as the data is loaded, you can do anything you want here:
            const onData = (ohlcData) => {
              // console.log('ohlcData:', ohlcData);
            }
            // Second function to be executed after the candle is drawn, you can add annotations here:
            const onCandleDrawn = (candle, index) => {
              // Check for tp/sl hit:
              ordersHistory.forEach((order) => {
                if (candle.high >= order.tp && !order.closed) {

                  order.closed = true;
                  order.closedPrice = order.tp;
                  order.closedTime = candle.time;
                  order.orderStatus = EnumOrderStatus.CLOSED_BY_TP,

                  sciChartSurface.annotations.add(
                    new CustomAnnotation({
                      x1: convertMT5DateToUnix(order.closedTime),
                      y1: order.tp,
                      verticalAnchorPoint: EVerticalAnchorPoint.Center,
                      horizontalAnchorPoint: EHorizontalAnchorPoint.Center,
                      svgString: signalAnnotation.svgString.sell,
                    })
                  );
                  sciChartSurface.annotations.add(
                    new LineAnnotation({
                      stroke: `#${greyColor}`,
                      strokeThickness: 1,
                      strokeDashArray: [5, 5],
                      x1: convertMT5DateToUnix(order.time),
                      x2: convertMT5DateToUnix(order.closedTime),
                      y1: order.price,
                      y2: order.closedPrice,
                    })
                  );
                }
                if (candle.low <= order.sl && !order.closed) {

                  order.closed = true;
                  order.closedPrice = order.sl;
                  order.closedTime = candle.time;
                  order.orderStatus = EnumOrderStatus.CLOSED_BY_SL,

                  sciChartSurface.annotations.add(
                    new CustomAnnotation({
                      x1: convertMT5DateToUnix(order.closedTime),
                      y1: order.sl,
                      verticalAnchorPoint: EVerticalAnchorPoint.Center,
                      horizontalAnchorPoint: EHorizontalAnchorPoint.Center,
                      svgString: signalAnnotation.svgString.sell,
                    })
                  );
                  sciChartSurface.annotations.add(
                    new LineAnnotation({
                      stroke: `#${greyColor}`,
                      strokeThickness: 1,
                      strokeDashArray: [5, 5],
                      x1: convertMT5DateToUnix(order.time),
                      x2: convertMT5DateToUnix(order.closedTime),
                      y1: order.price,
                      y2: order.closedPrice,
                    })
                  );
                }
              });

              // A FVG signal:
              const SignalCondition1 = () => {
                if (index < 3 || index > ohlcData.length - 2) return false;
                const prevCandle = ohlcData[index - 1];
                const nextCandle = ohlcData[index + 1];
                const isBullishFVG = nextCandle.low > prevCandle.high;
                const isBearishFVG = prevCandle.low > nextCandle.high;

                return false;
                //return isBullishFVG || isBearishFVG;
              };
              
              // A test signal condition for taking trades on each 400th candle:
              const SignalCondition2 = () => {
                const hourMinutes = () => candle.time.split(' ')[1].slice(0, 5);
                return hourMinutes() == '08:00'; // Take a trade at 08:00
              }

              if (SignalCondition1()) {
                const candlePosition = convertMT5DateToUnix(candle.time);
                const positionOfAnnotation = {
                  x1: candlePosition,
                  y1: candle.high,
                  verticalAnchorPoint: EVerticalAnchorPoint.Center,
                  horizontalAnchorPoint: EHorizontalAnchorPoint.Center,
                  svgString: signalAnnotation.svgString.bullish,
                }
                sciChartSurface.annotations.add(
                  new CustomAnnotation({
                    /*
                    stroke: '#999',
                    axisLabelFill: '#999',
                    strokeThickness: 1,
                    showLabel: true,
                    labelPlacement: ELabelPlacement.TopLeft,
                    labelValue: `${candle.time}`,
                    */
                    ...positionOfAnnotation,
                    y1: getCandleDirection(candle) == EnumDirection.BULL ? candle.low : candle.high,
                    svgString: getCandleDirection(candle) == EnumDirection.BULL ? signalAnnotation.svgString.bullish : signalAnnotation.svgString.bearish,
                  })
                );
              }

              if (SignalCondition2()) {
                const candlePosition = convertMT5DateToUnix(candle.time);
                
                // Add order to history:
                ordersHistory.push({
                  id: index,
                  time: candle.time,
                  price: candle.close,
                  sl: candle.close - slSize(),
                  tp: candle.close + tpSize(),
                  direction: EnumDirection.BULL,
                  orderStatus: EnumOrderStatus.PENDING,
                });

                // Add annotation from entry:
                sciChartSurface.annotations.add(
                  new CustomAnnotation({
                    x1: candlePosition,
                    y1: candle.close,
                    verticalAnchorPoint: EVerticalAnchorPoint.Center,
                    horizontalAnchorPoint: EHorizontalAnchorPoint.Center,
                    svgString: signalAnnotation.svgString.buy,
                  })
                );
              }

              if (index == ohlcData.length - 1) {
                
                const profitsInPoints = ordersHistory.reduce((acc, order) => {
                  if (order.orderStatus == EnumOrderStatus.CLOSED_BY_TP) {
                    return acc + tpSize();
                  }
                  if (order.orderStatus == EnumOrderStatus.CLOSED_BY_SL) {
                    return acc - slSize();
                  }
                  return acc;
                }, 0);

                console.log('Orders History:', ordersHistory);
                const winRate = ordersHistory.length > 0 ? (ordersHistory.filter((order) => order.orderStatus == EnumOrderStatus.CLOSED_BY_TP).length / ordersHistory.length * 100).toFixed(2) : 0;
                const result = `Check console for orders history\n\nTrade Taken: ${ordersHistory.length}\nWin Rate: ${winRate}% \n\nProfits: \n Money: ${(profitsInPoints * lotSize())}$\n Points: ${profitsInPoints} \n Pips: ${(profitsInPoints / 10)}`;
                document.getElementById('backtestingResult').value = result;
              }
            }

            // Create an OHLC data series
            const ohlcDataSeries = new OhlcDataSeries(wasmContext, {
              xValues: ohlcData.map((candle, index) => {
                
                onData(candle);

                let candleDateTime = candle.time; // excepted format: "1970.01.01 00:00:00"
                let unixTime = convertMT5DateToUnix(candleDateTime); // format: 1624982400 for 2021-06-29 00:00:00

                let candleTime = candleDateTime.split(' ')[1]; // get the time from the date string (00:00:00)
                let candleDateTimeStamp = getCandleChartAxisLocationFromDate(candleDateTime); // 1624982400

                let offsetedCandleTime = offsetCandleDateTimeStamp(candleDateTimeStamp); // Not really important for now, has we aren't offsetting anything yet.
                let dateOptionForSelect = candleDateTimeStamp;
                let backTestTime = getCandleChartAxisLocationFromDate(candleDateTime); // + 3600; // Actually the same as above (candleDateTimeStamp)

                var selectedTime = document.getElementById('backtesting-hour').value;

                if (candleTime == selectedTime) {
                  let btt = backTestTime; // * 1000;
                  let formatedDate = formatDateFromUnix(btt);

                  // Display Backtesting dates on the select element:
                  document
                    .getElementById('NavigateTroughtDates')
                    .innerHTML += `<option value="${unixTime}">
                      ${candleDateTime}</option>`;

                  // Backtesting line annotation:
                  sciChartSurface.annotations.add(
                    new VerticalLineAnnotation({
                      stroke: '#999',
                      axisLabelFill: '#999',
                      strokeThickness: 1,
                      x1: unixTime,
                      showLabel: true,
                      labelPlacement: ELabelPlacement.TopLeft,
                      labelValue: `${candleDateTime}`,
                    })
                  );
                }

                onCandleDrawn(candle, index);

                // Add annotations for MSS:
                /*
                  const indicateCandle = (candle, ohlcData, index) => {
                    const analysisRange = 1;
                    const currentCandleLocation = offsetedCandleTime(getCandleChartAxisLocationFromDate(candle.time));
                    const currentCandleLocationOffseted = offsetedCandleTime(getCandleChartAxisLocationFromDate(candle.time)) - 3600 * analysisRange;

                    if (index - analysisRange >= analysisRange && index - analysisRange < ohlcData.length && ohlcData[index - analysisRange] !== undefined) {
                      const x1 = currentCandleLocationOffseted;
                      const y1 = ohlcData[index - analysisRange].close;
                      const midCandleIndex = index - analysisRange;
                      const farLeftIndex = index - analysisRange - analysisRange;

                      isAfterPriceLower = ohlcData[index].high < ohlcData[midCandleIndex].high
                      isBeforePriceLower = ohlcData[farLeftIndex].high < ohlcData[midCandleIndex].high
                      if (isAfterPriceLower && isBeforePriceLower) {
                        const middleCandle = ohlcData[midCandleIndex];
                        //debugger
                        const middleCandleLocation = offsetedCandleTime(getCandleChartAxisLocationFromDate(middleCandle.time));
                        //console.log(x, a);
                        sciChartSurface.annotations.add(
                          new CustomAnnotation({
                            x1,
                            y1,
                            verticalAnchorPoint: EVerticalAnchorPoint.Top,
                            horizontalAnchorPoint: EHorizontalAnchorPoint.Center,
                            svgString:
                              '<svg id="Capa_1" xmlns="http://www.w3.org/2000/svg"><g transform="translate(-53.867218,-5.091687)"><path style="fill:#1cb61c;fill-opacity:0.34117647;stroke:#00b400;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1" d="m 55.47431,83.481251 c 7.158904,-7.408333 7.158904,-7.408333 7.158904,-7.408333 l 7.158906,7.408333 H 66.212668 V 94.593756 H 59.053761 V 83.481251 Z"/></g></svg>',
                          })
                        );
                      }
                    }
                  };

                  indicateCandle(candle, ohlcData, index);
                */

                return unixTime; // + 3600;
              }),
              openValues: ohlcData.map((candle) => candle.open),
              highValues: ohlcData.map((candle) => candle.high),
              lowValues: ohlcData.map((candle) => candle.low),
              closeValues: ohlcData.map((candle) => candle.close),
            });

            const xAxis = new DateTimeNumericAxis(wasmContext, { growBy });
            // Cursor labels:
            xAxis.labelProvider.formatCursorLabel = (dataValue) => {
              const unixDateStamp = Math.floor(dataValue); // Flooring it to remove milliseconds from that cursor data, as it is too much precise // - 3600;
              return formatDateFromUnix(unixDateStamp);
            };
            const yAxis = new NumericAxis(wasmContext, {
              labelPrecision: decimals,
              autoRange: EAutoRange.Always,
              growBy,
            });

            sciChartSurface.xAxes.add(xAxis);
            sciChartSurface.yAxes.add(yAxis);

            // Create an OHLC series
            sciChartSurface.renderableSeries.add(
              new FastCandlestickRenderableSeries(wasmContext, {
                dataSeries: ohlcDataSeries,
                strokeThickness: 1,
              })
            );

            // Add CursorModifier for crosshair
            sciChartSurface.chartModifiers.add(
              new CursorModifier({
                // Optional properties to configure what parts are shown
                showTooltip: false,
                showAxisLabels: true,
                showXLine: true,
                showYLine: true,
                // How close to a datapoint to show the tooltip? 10 = 10 pixels. 0 means always
                // hitTestRadius: 10,
                // Optional properties to configure the axis labels
                axisLabelFill: '#555',
                axisLabelStroke: '#ccc',
                // Optional properties to configure line and tooltip style
                crosshairStroke: '#555',
                crosshairStrokeThickness: 1,
                tooltipContainerBackground: '#000',
                // tooltipTextStroke: "#ff6600",
              })
            );

            document
              .getElementById('NavigateTroughtDates')
              .addEventListener('change', function (event) {
                const getCandleNumberByDay = (days) => 86400 * days; // Get the number of candles in a day (candle count for a entire day)
                const selectedDate = event.target.value;
                const rangeMinDate = parseInt(selectedDate) - 1800 // + half an hour
                const rangeMaxDate = parseInt(selectedDate) + getCandleNumberByDay(0.1); // getCandleChartAxisLocationFromDate(selectedDate) + getCandleNumberByDay(0.1); // half of a day
                const xAxis = sciChartSurface.xAxes.get(0);
                const yAxis = sciChartSurface.yAxes.get(0);

                xAxis.visibleRange = new NumberRange(
                  rangeMinDate,
                  rangeMaxDate
                );
                // yAxis.visibleRange = new NumberRange(1.07, 1.084);
                // sciChartSurface.zoomExtents();
              });

            sciChartSurface.chartModifiers.add(
              new MouseWheelZoomModifier(),
              new ZoomPanModifier(),
              new ZoomExtentsModifier(),
              new YAxisDragModifier({
                dragMode: EDragMode.Scaling,
              }),
              new XAxisDragModifier({
                dragMode: EDragMode.Scaling,
              })
            );
          };

          buildChartData(data);
          // Axios code to fetch data
          /*
            axios.get('https://api.binance.com/api/v3/klines?symbol=LTCBTC&interval=1m').then(response => {
              const data = response.data;
              // buildChartData(data);
            }).catch(error => {
              console.error('Error fetching data:', error);
            });
          */

          /*
            sciChartSurface.domCanvas2D.addEventListener('click', (event) => {
              //const coords = getCanvasCoordinatesFromEvent(sciChartSurface.domCanvas2D, event);
              //console.log(coords);
            });
          */

          let annotations = [];

          const refreshAnnotations = () => {
            annotations.forEach((annotation) => {
              console.log(annotation);
              /*document.getElementById('annotations').value = annotations
                .map((a) => JSON.stringify(a))
                .join('\n');*/
            });
          };

          const RRToolStyles = {
            strokeThickness: 0,
            xCoordinateMode: ECoordinateMode.DataValue,
            yCoordinateMode: ECoordinateMode.DataValue,
            annotationLayer: EAnnotationLayer.AboveChart,
            opacity: '15',
          };

          const RRToolBoxAnnotation = (
            xGraphValue,
            yGraphValue,
            options,
          ) =>
            new BoxAnnotation({
              ...RRToolStyles,
              x1: xGraphValue - 50,
              x2: xGraphValue + 300,
              y1: yGraphValue,
              ...options,
            });


          const addRRAnnotationBox = (ed) => {
            if (ed === EnumDirection.BULL) {
              sciChartSurface.annotations.add(
                RRToolBoxAnnotation(
                  coords.xGraphValue,
                  coords.yGraphValue,
                  {
                    fill: `#${bullishColor}${RRToolStyles.opacity}`,
                    y2: coords.yGraphValue + tpSize(),
                  },
                )
              )
              sciChartSurface.annotations.add(
                RRToolBoxAnnotation(
                  coords.xGraphValue,
                  coords.yGraphValue,
                  {
                    fill: `#${bearishColor}${RRToolStyles.opacity}`,
                    y2: coords.yGraphValue - slSize(),
                  },
                )
              )
            } else {
              sciChartSurface.annotations.add(
                RRToolBoxAnnotation(
                  coords.xGraphValue,
                  coords.yGraphValue,
                  {
                    fill: `#${bullishColor}${RRToolStyles.opacity}`,
                    y2: coords.yGraphValue - tpSize(),
                  },
                )
              )
              sciChartSurface.annotations.add(
                RRToolBoxAnnotation(
                  coords.xGraphValue,
                  coords.yGraphValue,
                  {
                    fill: `#${bearishColor}${RRToolStyles.opacity}`,
                    y2: coords.yGraphValue + slSize(),
                  },
                )
              )
            };
          };

          // Tools:

          let coords = null;
          let selectedTool = null;
          let clickCount = 0;

          let lineToolFirstPoint = null;
          let lineToolSecondPoint = null;
          let rectangleToolFirstPoint = null;
          let rectangleToolSecondPoint = null;

          sciChartSurface
            .domCanvas2D
            .addEventListener(
              'click',
              (event) => {
                const rect = sciChartSurface.domCanvas2D.getBoundingClientRect();
                const mouseX = event.clientX - rect.left;
                const mouseY = event.clientY - rect.top - 10; // -10 to offset the canvas position
                const xCoordCalc = sciChartSurface.xAxes.get(0).getCurrentCoordinateCalculator();
                const yCoordCalc = sciChartSurface.yAxes.get(0).getCurrentCoordinateCalculator();

                coords = {
                  xPosition: xCoordCalc.getDataValue(event.clientX),
                  yPosition: yCoordCalc.getDataValue(event.clientY),
                  xGraphValue: parseFloat(xCoordCalc.getDataValue(mouseX).toFixed(0)),
                  yGraphValue: parseFloat(yCoordCalc.getDataValue(mouseY).toFixed(decimals)),
                  x: xCoordCalc,
                  y: yCoordCalc,
                };

                // console.log(coords);

                /*if (isListeningForToolActions) {
                  addRRAnnotationBox(EnumDirection.BULL);
                  isListeningForToolActions = false;
                }*/

                if (selectedTool != null) {
                  clickCount++;
                } else {
                  clickCount = 0;
                }

                // console.log(clickCount);

                const lineToolActions = [
                  () => {
                    lineToolFirstPoint = coords;
                  },
                  () => {
                    lineToolSecondPoint = coords;
                    sciChartSurface.annotations.add(
                      new LineAnnotation({
                        stroke: `#${bullishColor}`,
                        strokeThickness: 1,
                        x1: lineToolFirstPoint.xGraphValue,
                        x2: lineToolSecondPoint.xGraphValue,
                        y1: lineToolFirstPoint.yGraphValue,
                        y2: lineToolSecondPoint.yGraphValue,
                      })
                    );
                    clickCount = 0;
                    selectedTool = null;
                  },
                ]

                const BOSActions = [
                  () => {
                    lineToolFirstPoint = coords;
                  },
                  () => {
                    lineToolSecondPoint = {
                      ...coords,
                      yGraphValue: lineToolFirstPoint.yGraphValue, 
                    };
                    sciChartSurface.annotations.add(
                      new LineAnnotation({
                        stroke: `#${bullishColor}`,
                        strokeThickness: 1,
                        x1: lineToolFirstPoint.xGraphValue,
                        x2: lineToolSecondPoint.xGraphValue,
                        y1: lineToolFirstPoint.yGraphValue,
                        y2: lineToolSecondPoint.yGraphValue,
                      })
                    );
                    clickCount = 0;
                    selectedTool = null;
                  },
                ]

                const CircleActions = [
                  () => {
                    lineToolFirstPoint = coords;
                    sciChartSurface.annotations.add(
                      new CustomAnnotation({
                        x1: lineToolFirstPoint.xGraphValue,
                        y1: lineToolFirstPoint.yGraphValue,
                        verticalAnchorPoint: EVerticalAnchorPoint.Center,
                        horizontalAnchorPoint: EHorizontalAnchorPoint.Center,
                        svgString: '<svg id="Capa_1" xmlns="http://www.w3.org/2000/svg">' +
                                   `<circle cx="10" cy="10" r="8" style="fill:#${bullishColor};fill-opacity:0.34117647;stroke:#${bullishColor};stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1" />` +
                                   '</svg>',
 
                      })
                    );
                    clickCount = 0;
                    selectedTool = null;
                  },
                  /*() => {
                    lineToolSecondPoint = {
                      ...coords,
                      yGraphValue: lineToolFirstPoint.yGraphValue, 
                    };
                  },*/
                ]

                const rectangleToolActions = [
                  () => {
                    rectangleToolFirstPoint = coords;
                  },
                  () => {
                    rectangleToolSecondPoint = coords;
                    sciChartSurface.annotations.add(
                      new BoxAnnotation({
                        x1: rectangleToolFirstPoint.xGraphValue,
                        x2: rectangleToolSecondPoint.xGraphValue,
                        y1: rectangleToolFirstPoint.yGraphValue,
                        y2: rectangleToolSecondPoint.yGraphValue,
                        fill: `#${bullishColor}${RRToolStyles.opacity}`,
                        stroke: `#${bullishColor}`,
                        strokeThickness: 1,
                        opacity: 0.5,
                      })
                    );
                    clickCount = 0;
                    selectedTool = null;
                  },
                ]

                switch (selectedTool) {
                  case 'RRBuy':
                    addRRAnnotationBox(EnumDirection.BULL);
                    clickCount = 0;
                    selectedTool = null;
                    break;
                  case 'RRSell':
                    addRRAnnotationBox(EnumDirection.SELL);
                    clickCount = 0;
                    selectedTool = null;
                    break;
                  case 'line':
                    stepByStep(clickCount, lineToolActions);
                    break;
                  case 'BOS':
                    stepByStep(clickCount, BOSActions);
                    break;
                  case 'Circle':
                    stepByStep(clickCount, CircleActions);
                    break;
                  case 'rectangle':
                    stepByStep(clickCount, rectangleToolActions);
                    break;
                  default: return;
                }
              },
            );

          document.querySelectorAll('[data-anotation]').forEach((button) => {
            button.removeAttribute('disabled');
            button.addEventListener('click', function () {
              let isListeningForToolActions = true;
              var anotationType = this.dataset.anotation;
              const rect = sciChartSurface.domCanvas2D.getBoundingClientRect();

              const rrTool = (enumDirection) => {
                isListeningForToolActions = true;
              };

              switch (anotationType) {
                case 'RRBuy':
                  selectedTool = 'RRBuy';
                  break;
                case 'RRSell':
                  selectedTool = 'RRSell';
                  break;
                case 'line':
                  selectedTool = 'line';
                  break;
                case 'BOS':
                  selectedTool = 'BOS';
                  break;
                case 'Circle':
                  selectedTool = 'Circle';
                  break;
                case 'rectangle':
                  selectedTool = 'rectangle';
                  break;
                default:
                  console.log('No type');
              }
            });
          });

          // Add some interaction modifiers to show zooming and panning
          // sciChartSurface.chartModifiers.add(new MouseWheelZoomModifier(), new ZoomPanModifier(), new ZoomExtentsModifier());
        })
        .catch((error) => {
          console.error('Error initializing SciChart:', error);
        });
    }

    // Add some interaction modifiers to show zooming and panning
    // sciChartSurface.chartModifiers.add(new MouseWheelZoomModifier(), new ZoomPanModifier(), new ZoomExtentsModifier());

    // Call initSciChart after the window has finished loading
    // window.onload = initSciChart;
  </script>
</body>

</html>